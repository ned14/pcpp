<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>pcpp.preprocessor API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>pcpp.preprocessor</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">#!/usr/bin/python
# Python C99 conforming preprocessor useful for generating single include files
# (C) 2017-2020 Niall Douglas http://www.nedproductions.biz/
# and (C) 2007-2017 David Beazley http://www.dabeaz.com/
# Started: Feb 2017
#
# This C preprocessor was originally written by David Beazley and the
# original can be found at https://github.com/dabeaz/ply/blob/master/ply/cpp.py
# This edition substantially improves on standards conforming output,
# getting quite close to what clang or GCC outputs.

from __future__ import generators, print_function, absolute_import

__all__ = [&#39;Preprocessor&#39;, &#39;PreprocessorHooks&#39;, &#39;OutputDirective&#39;, &#39;Action&#39;]

import sys, traceback, time, re

# Some Python 3 compatibility shims
if sys.version_info.major &lt; 3:
    STRING_TYPES = (str, unicode)
    FILE_TYPES = file
    clock = time.clock
else:
    STRING_TYPES = str
    xrange = range
    import io
    FILE_TYPES = io.IOBase
    clock = time.process_time

# -----------------------------------------------------------------------------
# Default preprocessor lexer definitions.   These tokens are enough to get
# a basic preprocessor working.   Other modules may import these if they want
# -----------------------------------------------------------------------------

tokens = (
   &#39;CPP_ID&#39;,&#39;CPP_INTEGER&#39;, &#39;CPP_FLOAT&#39;, &#39;CPP_STRING&#39;, &#39;CPP_CHAR&#39;, &#39;CPP_WS&#39;, &#39;CPP_LINECONT&#39;, &#39;CPP_COMMENT1&#39;, &#39;CPP_COMMENT2&#39;,
   &#39;CPP_POUND&#39;,&#39;CPP_DPOUND&#39;, &#39;CPP_PLUS&#39;, &#39;CPP_MINUS&#39;, &#39;CPP_STAR&#39;, &#39;CPP_FSLASH&#39;, &#39;CPP_PERCENT&#39;, &#39;CPP_BAR&#39;,
   &#39;CPP_AMPERSAND&#39;, &#39;CPP_TILDE&#39;, &#39;CPP_HAT&#39;, &#39;CPP_LESS&#39;, &#39;CPP_GREATER&#39;, &#39;CPP_EQUAL&#39;, &#39;CPP_EXCLAMATION&#39;,
   &#39;CPP_QUESTION&#39;, &#39;CPP_LPAREN&#39;, &#39;CPP_RPAREN&#39;, &#39;CPP_LBRACKET&#39;, &#39;CPP_RBRACKET&#39;, &#39;CPP_LCURLY&#39;, &#39;CPP_RCURLY&#39;,
   &#39;CPP_DOT&#39;, &#39;CPP_COMMA&#39;, &#39;CPP_SEMICOLON&#39;, &#39;CPP_COLON&#39;, &#39;CPP_BSLASH&#39;, &#39;CPP_SQUOTE&#39;, &#39;CPP_DQUOTE&#39;,

   &#39;CPP_DEREFERENCE&#39;, &#39;CPP_MINUSEQUAL&#39;, &#39;CPP_MINUSMINUS&#39;, &#39;CPP_LSHIFT&#39;, &#39;CPP_LESSEQUAL&#39;, &#39;CPP_RSHIFT&#39;,
   &#39;CPP_GREATEREQUAL&#39;, &#39;CPP_LOGICALOR&#39;, &#39;CPP_OREQUAL&#39;, &#39;CPP_LOGICALAND&#39;, &#39;CPP_ANDEQUAL&#39;, &#39;CPP_EQUALITY&#39;,
   &#39;CPP_INEQUALITY&#39;, &#39;CPP_XOREQUAL&#39;, &#39;CPP_MULTIPLYEQUAL&#39;, &#39;CPP_DIVIDEEQUAL&#39;, &#39;CPP_PLUSEQUAL&#39;, &#39;CPP_PLUSPLUS&#39;,
   &#39;CPP_PERCENTEQUAL&#39;, &#39;CPP_LSHIFTEQUAL&#39;, &#39;CPP_RSHIFTEQUAL&#39;
)

literals = &#34;+-*/%|&amp;~^&lt;&gt;=!?()[]{}.,;:\\\&#39;\&#34;&#34;

# Whitespace, but don&#39;t match past the end of a line
def t_CPP_WS(t):
    r&#39;([ \t]+|\n)&#39;
    t.lexer.lineno += t.value.count(&#34;\n&#34;)
    return t

# Line continuation, accept whitespace between the backslash and new line
def t_CPP_LINECONT(t):
    r&#39;\\[ \t]*\n&#39;
    t.value = t.value[1:-1]
    t.lexer.lineno += 1
    return t
_string_literal_linecont_pat = re.compile(r&#39;\\[ \t]*\n&#39;)

t_CPP_POUND = r&#39;\#&#39;
t_CPP_DPOUND = r&#39;\#\#&#39;
t_CPP_PLUS = r&#39;\+&#39;
t_CPP_MINUS = r&#39;-&#39;
t_CPP_STAR = r&#39;\*&#39;
t_CPP_FSLASH = r&#39;/&#39;
t_CPP_PERCENT = r&#39;%&#39;
t_CPP_BAR = r&#39;\|&#39;
t_CPP_AMPERSAND = r&#39;&amp;&#39;
t_CPP_TILDE = r&#39;~&#39;
t_CPP_HAT = r&#39;\^&#39;
t_CPP_LESS = r&#39;&lt;&#39;
t_CPP_GREATER = r&#39;&gt;&#39;
t_CPP_EQUAL = r&#39;=&#39;
t_CPP_EXCLAMATION = r&#39;!&#39;
t_CPP_QUESTION = r&#39;\?&#39;
t_CPP_LPAREN = r&#39;\(&#39;
t_CPP_RPAREN = r&#39;\)&#39;
t_CPP_LBRACKET = r&#39;\[&#39;
t_CPP_RBRACKET = r&#39;\]&#39;
t_CPP_LCURLY = r&#39;{&#39;
t_CPP_RCURLY = r&#39;}&#39;
t_CPP_DOT = r&#39;\.&#39;
t_CPP_COMMA = r&#39;,&#39;
t_CPP_SEMICOLON = r&#39;;&#39;
t_CPP_COLON = r&#39;:&#39;
t_CPP_BSLASH = r&#39;\\&#39;
t_CPP_SQUOTE = r&#34;&#39;&#34;
t_CPP_DQUOTE = r&#39;&#34;&#39;

t_CPP_DEREFERENCE = r&#39;-&gt;&#39;
t_CPP_MINUSEQUAL = r&#39;-=&#39;
t_CPP_MINUSMINUS = r&#39;--&#39;
t_CPP_LSHIFT = r&#39;&lt;&lt;&#39;
t_CPP_LESSEQUAL = r&#39;&lt;=&#39;
t_CPP_RSHIFT = r&#39;&gt;&gt;&#39;
t_CPP_GREATEREQUAL = r&#39;&gt;=&#39;
t_CPP_LOGICALOR = r&#39;\|\|&#39;
t_CPP_OREQUAL = r&#39;\|=&#39;
t_CPP_LOGICALAND = r&#39;&amp;&amp;&#39;
t_CPP_ANDEQUAL = r&#39;&amp;=&#39;
t_CPP_EQUALITY = r&#39;==&#39;
t_CPP_INEQUALITY = r&#39;!=&#39;
t_CPP_XOREQUAL = r&#39;^=&#39;
t_CPP_MULTIPLYEQUAL = r&#39;\*=&#39;
t_CPP_DIVIDEEQUAL = r&#39;/=&#39;
t_CPP_PLUSEQUAL = r&#39;\+=&#39;
t_CPP_PLUSPLUS = r&#39;\+\+&#39;
t_CPP_PERCENTEQUAL = r&#39;%=&#39;
t_CPP_LSHIFTEQUAL = r&#39;&lt;&lt;=&#39;
t_CPP_RSHIFTEQUAL = r&#39;&gt;&gt;=&#39;


# Identifier
t_CPP_ID = r&#39;[A-Za-z_][\w_]*&#39;

# Integer literal
def CPP_INTEGER(t):
    r&#39;(((((0x)|(0X))[0-9a-fA-F]+)|(\d+))([uU][lL]|[lL][uU]|[uU]|[lL])?)&#39;
    return t

t_CPP_INTEGER = CPP_INTEGER

# Floating literal
t_CPP_FLOAT = r&#39;((\d+)(\.\d+)(e(\+|-)?(\d+))?|(\d+)e(\+|-)?(\d+))([lL]|[fF])?&#39;

# String literal
def t_CPP_STRING(t):
    r&#39;\&#34;([^\\\n]|(\\(.|\n)))*?\&#34;&#39;
    t.value, subs_made = _string_literal_linecont_pat.subn(&#39;&#39;, t.value)
    t.lexer.lineno += subs_made + t.value.count(&#34;\n&#34;)
    return t

# Character constant &#39;c&#39; or L&#39;c&#39;
def t_CPP_CHAR(t):
    r&#39;(L)?\&#39;([^\\\n]|(\\(.|\n)))*?\&#39;&#39;
    t.lexer.lineno += t.value.count(&#34;\n&#34;)
    return t

# Comment
def t_CPP_COMMENT1(t):
    r&#39;(/\*(.|\n)*?\*/)&#39;
    ncr = t.value.count(&#34;\n&#34;)
    t.lexer.lineno += ncr
    return t

# Line comment
def t_CPP_COMMENT2(t):
    r&#39;(//[^\n]*)&#39;
    return t
    
def t_error(t):
    t.type = t.value[0]
    t.value = t.value[0]
    t.lexer.skip(1)
    return t

import codecs
import copy
import time
import os.path

# Python 2/3 compatible way of importing a subpackage
oldsyspath = sys.path
sys.path = [ os.path.join( os.path.dirname( os.path.abspath(__file__) ), &#34;ply&#34; ) ] + sys.path
from ply import lex
from ply.lex import LexToken
sys.path = oldsyspath
del oldsyspath

# -----------------------------------------------------------------------------
# trigraph()
# 
# Given an input string, this function replaces all trigraph sequences. 
# The following mapping is used:
#
#     ??=    #
#     ??/    \
#     ??&#39;    ^
#     ??(    [
#     ??)    ]
#     ??!    |
#     ??&lt;    {
#     ??&gt;    }
#     ??-    ~
# -----------------------------------------------------------------------------

_trigraph_pat = re.compile(r&#39;&#39;&#39;\?\?[=/\&#39;\(\)\!&lt;&gt;\-]&#39;&#39;&#39;)
_trigraph_rep = {
    &#39;=&#39;:&#39;#&#39;,
    &#39;/&#39;:&#39;\\&#39;,
    &#34;&#39;&#34;:&#39;^&#39;,
    &#39;(&#39;:&#39;[&#39;,
    &#39;)&#39;:&#39;]&#39;,
    &#39;!&#39;:&#39;|&#39;,
    &#39;&lt;&#39;:&#39;{&#39;,
    &#39;&gt;&#39;:&#39;}&#39;,
    &#39;-&#39;:&#39;~&#39;
}

def trigraph(input):
    return _trigraph_pat.sub(lambda g: _trigraph_rep[g.group()[-1]],input)

# ------------------------------------------------------------------
# Macro object
#
# This object holds information about preprocessor macros
#
#    .name      - Macro name (string)
#    .value     - Macro value (a list of tokens)
#    .arglist   - List of argument names
#    .variadic  - Boolean indicating whether or not variadic macro
#    .vararg    - Name of the variadic parameter
#
# When a macro is created, the macro replacement token sequence is
# pre-scanned and used to create patch lists that are later used
# during macro expansion
# ------------------------------------------------------------------

class Macro(object):
    def __init__(self,name,value,arglist=None,variadic=False):
        self.name = name
        self.value = value
        self.arglist = arglist
        self.variadic = variadic
        if variadic:
            self.vararg = arglist[-1]
        self.source = None
        self.lineno = None
    def __repr__(self):
        return &#34;%s(%s)=%s&#34; % (self.name, self.arglist, self.value)

# ------------------------------------------------------------------
# Preprocessor event hooks
#
# Override these to customise preprocessing
# ------------------------------------------------------------------

class Action(object):
    &#34;&#34;&#34;What kind of abort processing to do in OutputDirective&#34;&#34;&#34;
    IgnoreAndPassThrough = 0
    &#34;&#34;&#34;Abort processing (don&#39;t execute), but pass the directive through to output&#34;&#34;&#34;
    IgnoreAndRemove = 1
    &#34;&#34;&#34;Abort processing (don&#39;t execute), and remove from output&#34;&#34;&#34;

class OutputDirective(Exception):
    &#34;&#34;&#34;Raise this exception to abort processing of a preprocessor directive and
    to instead output it as is into the output&#34;&#34;&#34;
    def __init__(self, action):
        self.action = action

class PreprocessorHooks(object):
    &#34;&#34;&#34;Override these in your subclass of Preprocessor to customise preprocessing&#34;&#34;&#34;
    def __init__(self):
        self.lastdirective = None

    def on_error(self,file,line,msg):
        &#34;&#34;&#34;Called when the preprocessor has encountered an error, e.g. malformed input.
        
        The default simply prints to stderr and increments the return code.
        &#34;&#34;&#34;
        print(&#34;%s:%d error: %s&#34; % (file,line,msg), file = sys.stderr)
        self.return_code += 1
        
    def on_file_open(self,is_system_include,includepath):
        &#34;&#34;&#34;Called to open a file for reading.
        
        This hook provides the ability to use ``chardet``, or any other mechanism,
        to inspect a file for its text encoding, and open it appropriately. Be
        aware that this function is used to probe for possible include file locations,
        so ``includepath`` may not exist. If it does not, raise the appropriate
        ``IOError`` exception.
        
        The default calls ``io.open(includepath, &#39;r&#39;, encoding = self.assume_encoding)``,
        examines if it starts with a BOM (if so, it removes it), and returns the file
        object opened. This raises the appropriate exception if the path was not found.
        &#34;&#34;&#34;
        if sys.version_info.major &lt; 3:
            assert self.assume_encoding is None
            ret = open(includepath, &#39;r&#39;)
        else:
            ret = open(includepath, &#39;r&#39;, encoding = self.assume_encoding)
        bom = ret.read(1)
        #print(repr(bom))
        if bom != &#39;\ufeff&#39;:
            ret.seek(0)
        return ret

    def on_include_not_found(self,is_malformed,is_system_include,curdir,includepath):
        &#34;&#34;&#34;Called when a #include wasn&#39;t found.
        
        Raise OutputDirective to pass through or remove, else return
        a suitable path. Remember that Preprocessor.add_path() lets you add search paths.
        
        The default calls ``self.on_error()`` with a suitable error message about the
        include file not found if ``is_malformed`` is False, else a suitable error
        message about a malformed #include, and in both cases raises OutputDirective
        (pass through).
        &#34;&#34;&#34;
        if is_malformed:
            self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Malformed #include statement: %s&#34; % includepath)
        else:
            self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Include file &#39;%s&#39; not found&#34; % includepath)
        raise OutputDirective(Action.IgnoreAndPassThrough)
        
    def on_unknown_macro_in_defined_expr(self,tok):
        &#34;&#34;&#34;Called when an expression passed to an #if contained a defined operator
        performed on something unknown.
        
        Return True if to treat it as defined, False if to treat it as undefined,
        raise OutputDirective to pass through without execution, or return None to
        pass through the mostly expanded #if expression apart from the unknown defined.
        
        The default returns False, as per the C standard.
        &#34;&#34;&#34;
        return False

    def on_unknown_macro_in_expr(self,tok):
        &#34;&#34;&#34;Called when an expression passed to an #if contained something unknown.
        
        Return what value it should be, raise OutputDirective to pass through
        without execution, or return None to pass through the mostly expanded #if
        expression apart from the unknown item.
        
        The default returns a token for an integer 0L, as per the C standard.
        &#34;&#34;&#34;
        tok.type = self.t_INTEGER
        tok.value = self.t_INTEGER_TYPE(&#34;0L&#34;)
        return tok
    
    def on_directive_handle(self,directive,toks,ifpassthru,precedingtoks):
        &#34;&#34;&#34;Called when there is one of
        
        define, include, undef, ifdef, ifndef, if, elif, else, endif
        
        Return True to execute and remove from the output, raise OutputDirective
        to pass through or remove without execution, or return None to execute
        AND pass through to the output (this only works for #define, #undef).
        
        The default returns True (execute and remove from the output).

        directive is the directive, toks is the tokens after the directive,
        ifpassthru is whether we are in passthru mode, precedingtoks is the
        tokens preceding the directive from the # token until the directive.
        &#34;&#34;&#34;
        self.lastdirective = directive
        return True
        
    def on_directive_unknown(self,directive,toks,ifpassthru,precedingtoks):
        &#34;&#34;&#34;Called when the preprocessor encounters a #directive it doesn&#39;t understand.
        This is actually quite an extensive list as it currently only understands:
        
        define, include, undef, ifdef, ifndef, if, elif, else, endif
        
        Return True to remove from the output, raise OutputDirective
        to pass through or remove, or return None to
        pass through into the output.
        
        The default handles #error and #warning by printing to stderr and returning True
        (remove from output). For everything else it returns None (pass through into output).

        directive is the directive, toks is the tokens after the directive,
        ifpassthru is whether we are in passthru mode, precedingtoks is the
        tokens preceding the directive from the # token until the directive.
        &#34;&#34;&#34;
        if directive.value == &#39;error&#39;:
            print(&#34;%s:%d error: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
            self.return_code += 1
            return True
        elif directive.value == &#39;warning&#39;:
            print(&#34;%s:%d warning: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
            return True
        return None
        
    def on_potential_include_guard(self,macro):
        &#34;&#34;&#34;Called when the preprocessor encounters an #ifndef macro or an #if !defined(macro)
        as the first non-whitespace thing in a file. Unlike the other hooks, macro is a string,
        not a token.
        &#34;&#34;&#34;
        pass
    
    def on_comment(self,tok):
        &#34;&#34;&#34;Called when the preprocessor encounters a comment token. You can modify the token
        in place. You must return True to let the comment pass through, else it will be removed.
        
        Returning False or None modifies the token to become whitespace, becoming a single space
        if the comment is a block comment, else a single new line if the comment is a line comment.
        &#34;&#34;&#34;
        return None

# ------------------------------------------------------------------
# File inclusion timings
#
# Useful for figuring out how long a sequence of preprocessor inclusions actually is
# ------------------------------------------------------------------

class FileInclusionTime(object):
    &#34;&#34;&#34;The seconds taken to #include another file&#34;&#34;&#34;
    def __init__(self,including_path,included_path,included_abspath,depth):
        self.including_path = including_path
        self.included_path = included_path
        self.included_abspath = included_abspath
        self.depth = depth
        self.elapsed = 0.0

# ------------------------------------------------------------------
# Preprocessor object
#
# Object representing a preprocessor.  Contains macro definitions,
# include directories, and other information
# ------------------------------------------------------------------

class Preprocessor(PreprocessorHooks):    
    def __init__(self,lexer=None):
        super(Preprocessor, self).__init__()
        if lexer is None:
            lexer = lex.lex()
        self.lexer = lexer
        self.macros = { }
        self.path = []           # list of -I formal search paths for includes
        self.temp_path = []      # list of temporary search paths for includes
        self.rewrite_paths = [(re.escape(os.path.abspath(&#39;&#39;) + os.sep) + &#39;(.*)&#39;, &#39;\\1&#39;)]
        self.include_once = {}
        self.include_depth = 0
        self.include_times = []  # list of FileInclusionTime
        self.return_code = 0
        self.debugout = None
        self.auto_pragma_once_enabled = True
        self.line_directive = &#39;#line&#39;
        self.compress = False
        self.assume_encoding = None

        # Probe the lexer for selected tokens
        self.__lexprobe()

        tm = time.localtime()
        self.define(&#34;__DATE__ \&#34;%s\&#34;&#34; % time.strftime(&#34;%b %d %Y&#34;,tm))
        self.define(&#34;__TIME__ \&#34;%s\&#34;&#34; % time.strftime(&#34;%H:%M:%S&#34;,tm))
        self.define(&#34;__PCPP__ 1&#34;)
        self.expand_linemacro = True
        self.expand_filemacro = True
        self.expand_countermacro = True
        self.linemacro = 0
        self.linemacrodepth = 0
        self.countermacro = 0
        self.parser = None

    # -----------------------------------------------------------------------------
    # tokenize()
    #
    # Utility function. Given a string of text, tokenize into a list of tokens
    # -----------------------------------------------------------------------------

    def tokenize(self,text):
        &#34;&#34;&#34;Utility function. Given a string of text, tokenize into a list of tokens&#34;&#34;&#34;
        tokens = []
        self.lexer.input(text)
        while True:
            tok = self.lexer.token()
            if not tok: break
            tok.source = &#39;&#39;
            tokens.append(tok)
        return tokens

    # ----------------------------------------------------------------------
    # __lexprobe()
    #
    # This method probes the preprocessor lexer object to discover
    # the token types of symbols that are important to the preprocessor.
    # If this works right, the preprocessor will simply &#34;work&#34;
    # with any suitable lexer regardless of how tokens have been named.
    # ----------------------------------------------------------------------

    def __lexprobe(self):

        # Determine the token type for identifiers
        self.lexer.input(&#34;identifier&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;identifier&#34;:
            print(&#34;Couldn&#39;t determine identifier type&#34;)
        else:
            self.t_ID = tok.type

        # Determine the token type for integers
        self.lexer.input(&#34;12345&#34;)
        tok = self.lexer.token()
        if not tok or int(tok.value) != 12345:
            print(&#34;Couldn&#39;t determine integer type&#34;)
        else:
            self.t_INTEGER = tok.type
            self.t_INTEGER_TYPE = type(tok.value)

        # Determine the token type for character
        self.lexer.input(&#34;&#39;a&#39;&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;&#39;a&#39;&#34;:
            print(&#34;Couldn&#39;t determine character type&#34;)
        else:
            self.t_CHAR = tok.type
            
        # Determine the token type for strings enclosed in double quotes
        self.lexer.input(&#34;\&#34;filename\&#34;&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;\&#34;filename\&#34;&#34;:
            print(&#34;Couldn&#39;t determine string type&#34;)
        else:
            self.t_STRING = tok.type

        # Determine the token type for whitespace--if any
        self.lexer.input(&#34;  &#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;  &#34;:
            self.t_SPACE = None
        else:
            self.t_SPACE = tok.type

        # Determine the token type for newlines
        self.lexer.input(&#34;\n&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;\n&#34;:
            self.t_NEWLINE = None
            print(&#34;Couldn&#39;t determine token for newlines&#34;)
        else:
            self.t_NEWLINE = tok.type

        # Determine the token type for line continuations
        self.lexer.input(&#34;\\     \n&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;     &#34;:
            self.t_LINECONT = None
            print(&#34;Couldn&#39;t determine token for line continuations&#34;)
        else:
            self.t_LINECONT = tok.type

        self.t_WS = (self.t_SPACE, self.t_NEWLINE, self.t_LINECONT)

        self.lexer.input(&#34;##&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;##&#34;:
            print(&#34;Couldn&#39;t determine token for token pasting operator&#34;)
        else:
            self.t_DPOUND = tok.type

        self.lexer.input(&#34;?&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;?&#34;:
            print(&#34;Couldn&#39;t determine token for ternary operator&#34;)
        else:
            self.t_TERNARY = tok.type

        self.lexer.input(&#34;:&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;:&#34;:
            print(&#34;Couldn&#39;t determine token for ternary operator&#34;)
        else:
            self.t_COLON = tok.type

        self.lexer.input(&#34;/* comment */&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;/* comment */&#34;:
            print(&#34;Couldn&#39;t determine comment type&#34;)
        else:
            self.t_COMMENT1 = tok.type

        self.lexer.input(&#34;// comment&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;// comment&#34;:
            print(&#34;Couldn&#39;t determine comment type&#34;)
        else:
            self.t_COMMENT2 = tok.type
            
        self.t_COMMENT = (self.t_COMMENT1, self.t_COMMENT2)

        # Check for other characters used by the preprocessor
        chars = [ &#39;&lt;&#39;,&#39;&gt;&#39;,&#39;#&#39;,&#39;##&#39;,&#39;\\&#39;,&#39;(&#39;,&#39;)&#39;,&#39;,&#39;,&#39;.&#39;]
        for c in chars:
            self.lexer.input(c)
            tok = self.lexer.token()
            if not tok or tok.value != c:
                print(&#34;Unable to lex &#39;%s&#39; required for preprocessor&#34; % c)

    # ----------------------------------------------------------------------
    # add_path()
    #
    # Adds a search path to the preprocessor.  
    # ----------------------------------------------------------------------

    def add_path(self,path):
        &#34;&#34;&#34;Adds a search path to the preprocessor. &#34;&#34;&#34;
        self.path.append(path)
        # If the search path being added is relative, or has a common ancestor to the
        # current working directory, add a rewrite to relativise includes from this
        # search path
        relpath = None
        try:
            relpath = os.path.relpath(path)
        except: pass
        if relpath is not None:
            self.rewrite_paths += [(re.escape(os.path.abspath(path) + os.sep) + &#39;(.*)&#39;, os.path.join(relpath, &#39;\\1&#39;))]


    # ----------------------------------------------------------------------
    # group_lines()
    #
    # Given an input string, this function splits it into lines.  Trailing whitespace
    # is removed. This function forms the lowest level of the preprocessor---grouping
    # text into a line-by-line format.
    # ----------------------------------------------------------------------

    def group_lines(self,input,abssource):
        r&#34;&#34;&#34;Given an input string, this function splits it into lines.  Trailing whitespace
        is removed. This function forms the lowest level of the preprocessor---grouping
        text into a line-by-line format.
        &#34;&#34;&#34;
        lex = self.lexer.clone()
        lines = [x.rstrip() for x in input.splitlines()]

        input = &#34;\n&#34;.join(lines)
        lex.input(input)
        lex.lineno = 1

        current_line = []
        while True:
            tok = lex.token()
            if not tok:
                break
            tok.source = abssource
            current_line.append(tok)
            if tok.type in self.t_WS and tok.value == &#39;\n&#39;:
                yield current_line
                current_line = []

        if current_line:
            nltok = copy.copy(current_line[-1])
            nltok.type = self.t_NEWLINE
            nltok.value = &#39;\n&#39;
            current_line.append(nltok)
            yield current_line

    # ----------------------------------------------------------------------
    # tokenstrip()
    # 
    # Remove leading/trailing whitespace tokens from a token list
    # ----------------------------------------------------------------------

    def tokenstrip(self,tokens):
        &#34;&#34;&#34;Remove leading/trailing whitespace tokens from a token list&#34;&#34;&#34;
        i = 0
        while i &lt; len(tokens) and tokens[i].type in self.t_WS:
            i += 1
        del tokens[:i]
        i = len(tokens)-1
        while i &gt;= 0 and tokens[i].type in self.t_WS:
            i -= 1
        del tokens[i+1:]
        return tokens


    # ----------------------------------------------------------------------
    # collect_args()
    #
    # Collects comma separated arguments from a list of tokens.   The arguments
    # must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
    # where tokencount is the number of tokens consumed, args is a list of arguments,
    # and positions is a list of integers containing the starting index of each
    # argument.  Each argument is represented by a list of tokens.
    #
    # When collecting arguments, leading and trailing whitespace is removed
    # from each argument.  
    #
    # This function properly handles nested parenthesis and commas---these do not
    # define new arguments.
    # ----------------------------------------------------------------------

    def collect_args(self,tokenlist,ignore_errors=False):
        &#34;&#34;&#34;Collects comma separated arguments from a list of tokens.   The arguments
        must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
        where tokencount is the number of tokens consumed, args is a list of arguments,
        and positions is a list of integers containing the starting index of each
        argument.  Each argument is represented by a list of tokens.
        
        When collecting arguments, leading and trailing whitespace is removed
        from each argument.  
        
        This function properly handles nested parenthesis and commas---these do not
        define new arguments.&#34;&#34;&#34;
        args = []
        positions = []
        current_arg = []
        nesting = 1
        tokenlen = len(tokenlist)
    
        # Search for the opening &#39;(&#39;.
        i = 0
        while (i &lt; tokenlen) and (tokenlist[i].type in self.t_WS):
            i += 1

        if (i &lt; tokenlen) and (tokenlist[i].value == &#39;(&#39;):
            positions.append(i+1)
        else:
            if not ignore_errors:
                self.on_error(tokenlist[0].source,tokenlist[0].lineno,&#34;Missing &#39;(&#39; in macro arguments&#34;)
            return 0, [], []

        i += 1

        while i &lt; tokenlen:
            t = tokenlist[i]
            if t.value == &#39;(&#39;:
                current_arg.append(t)
                nesting += 1
            elif t.value == &#39;)&#39;:
                nesting -= 1
                if nesting == 0:
                    args.append(self.tokenstrip(current_arg))
                    positions.append(i)
                    return i+1,args,positions
                current_arg.append(t)
            elif t.value == &#39;,&#39; and nesting == 1:
                args.append(self.tokenstrip(current_arg))
                positions.append(i+1)
                current_arg = []
            else:
                current_arg.append(t)
            i += 1
    
        # Missing end argument
        if not ignore_errors:
            self.on_error(tokenlist[-1].source,tokenlist[-1].lineno,&#34;Missing &#39;)&#39; in macro arguments&#34;)
        return 0, [],[]

    # ----------------------------------------------------------------------
    # macro_prescan()
    #
    # Examine the macro value (token sequence) and identify patch points
    # This is used to speed up macro expansion later on---we&#39;ll know
    # right away where to apply patches to the value to form the expansion
    # ----------------------------------------------------------------------
    
    def macro_prescan(self,macro):
        &#34;&#34;&#34;Examine the macro value (token sequence) and identify patch points
        This is used to speed up macro expansion later on---we&#39;ll know
        right away where to apply patches to the value to form the expansion&#34;&#34;&#34;
        macro.patch     = []             # Standard macro arguments 
        macro.str_patch = []             # String conversion expansion
        macro.var_comma_patch = []       # Variadic macro comma patch
        i = 0
        #print(&#34;BEFORE&#34;, macro.value)
        while i &lt; len(macro.value):
            if macro.value[i].type == self.t_ID and macro.value[i].value in macro.arglist:
                argnum = macro.arglist.index(macro.value[i].value)
                # Conversion of argument to a string
                j = i - 1
                while j &gt;= 0 and macro.value[j].type in self.t_WS:
                    j -= 1
                if j &gt;= 0 and macro.value[j].value == &#39;#&#39;:
                    macro.value[i] = copy.copy(macro.value[i])
                    macro.value[i].type = self.t_STRING
                    while i &gt; j:
                        del macro.value[j]
                        i -= 1
                    macro.str_patch.append((argnum,i))
                    continue
                # Concatenation
                elif (i &gt; 0 and macro.value[i-1].value == &#39;##&#39;):
                    macro.patch.append((&#39;t&#39;,argnum,i))
                    i += 1
                    continue
                elif ((i+1) &lt; len(macro.value) and macro.value[i+1].value == &#39;##&#39;):
                    macro.patch.append((&#39;t&#39;,argnum,i))
                    i += 1
                    continue
                # Standard expansion
                else:
                    macro.patch.append((&#39;e&#39;,argnum,i))
            elif macro.value[i].value == &#39;##&#39;:
                if macro.variadic and (i &gt; 0) and (macro.value[i-1].value == &#39;,&#39;) and \
                        ((i+1) &lt; len(macro.value)) and (macro.value[i+1].type == self.t_ID) and \
                        (macro.value[i+1].value == macro.vararg):
                    macro.var_comma_patch.append(i-1)
            i += 1
        macro.patch.sort(key=lambda x: x[2],reverse=True)
        #print(&#34;AFTER&#34;, macro.value)

    # ----------------------------------------------------------------------
    # macro_expand_args()
    #
    # Given a Macro and list of arguments (each a token list), this method
    # returns an expanded version of a macro.  The return value is a token sequence
    # representing the replacement macro tokens
    # ----------------------------------------------------------------------

    def macro_expand_args(self,macro,args):
        &#34;&#34;&#34;Given a Macro and list of arguments (each a token list), this method
        returns an expanded version of a macro.  The return value is a token sequence
        representing the replacement macro tokens&#34;&#34;&#34;
        # Make a copy of the macro token sequence
        rep = [copy.copy(_x) for _x in macro.value]

        # Make string expansion patches.  These do not alter the length of the replacement sequence
        str_expansion = {}
        for argnum, i in macro.str_patch:
            if argnum not in str_expansion:
                # Strip all non-space whitespace before stringization
                tokens = copy.copy(args[argnum])
                for j in xrange(len(tokens)):
                    if tokens[j].type in self.t_WS and tokens[j].type != self.t_LINECONT:
                        tokens[j].value = &#39; &#39;
                # Collapse all multiple whitespace too
                j = 0
                while j &lt; len(tokens) - 1:
                    if tokens[j].type in self.t_WS and tokens[j+1].type in self.t_WS:
                        del tokens[j+1]
                    else:
                        j += 1
                str = &#34;&#34;.join([x.value for x in tokens])
                str = str.replace(&#34;\\&#34;,&#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;)
                str_expansion[argnum] = &#39;&#34;&#39; + str + &#39;&#34;&#39;
            rep[i] = copy.copy(rep[i])
            rep[i].value = str_expansion[argnum]

        # Make the variadic macro comma patch.  If the variadic macro argument is empty, we get rid
        comma_patch = False
        if macro.variadic and not args[-1]:
            for i in macro.var_comma_patch:
                rep[i] = None
                comma_patch = True

        # Make all other patches.   The order of these matters.  It is assumed that the patch list
        # has been sorted in reverse order of patch location since replacements will cause the
        # size of the replacement sequence to expand from the patch point.
        
        expanded = { }
        #print(&#34;***&#34;, macro)
        #print(macro.patch)
        for ptype, argnum, i in macro.patch:
            # Concatenation.   Argument is left unexpanded
            if ptype == &#39;t&#39;:
                rep[i:i+1] = args[argnum]
            # Normal expansion.  Argument is macro expanded first
            elif ptype == &#39;e&#39;:
                if argnum not in expanded:
                    expanded[argnum] = self.expand_macros(args[argnum])
                rep[i:i+1] = expanded[argnum]

        # Get rid of removed comma if necessary
        if comma_patch:
            rep = [_i for _i in rep if _i]
            
        # Do a token concatenation pass, stitching any tokens separated by ## into a single token
        while len(rep) and rep[0].type == self.t_DPOUND:
            del rep[0]
        while len(rep) and rep[-1].type == self.t_DPOUND:
            del rep[-1]
        i = 1
        stitched = False
        while i &lt; len(rep) - 1:
            if rep[i].type == self.t_DPOUND:
                j = i + 1
                while rep[j].type == self.t_DPOUND:
                    j += 1
                rep[i-1] = copy.copy(rep[i-1])
                rep[i-1].type = None
                rep[i-1].value += rep[j].value
                while j &gt;= i:
                    del rep[i]
                    j -= 1
                stitched = True
            else:
                i += 1
        if stitched:
            # Stitched tokens will have unknown type, so figure those out now
            i = 0
            lex = self.lexer.clone()
            while i &lt; len(rep):
                if rep[i].type is None:
                    lex.input(rep[i].value)
                    toks = []
                    while True:
                        tok = lex.token()
                        if not tok:
                            break
                        toks.append(tok)
                    if len(toks) != 1:
                        # Split it once again
                        while len(toks) &gt; 1:
                            rep.insert(i+1, copy.copy(rep[i]))
                            rep[i+1].value = toks[-1].value
                            rep[i+1].type = toks[-1].type
                            toks.pop()
                        rep[i].value = toks[0].value
                        rep[i].type = toks[0].type
                    else:
                        rep[i].type = toks[0].type
                i += 1

        #print rep
        return rep


    # ----------------------------------------------------------------------
    # expand_macros()
    #
    # Given a list of tokens, this function performs macro expansion.
    # ----------------------------------------------------------------------

    def expand_macros(self,tokens,expanding_from=[]):
        &#34;&#34;&#34;Given a list of tokens, this function performs macro expansion.&#34;&#34;&#34;
        # Each token needs to track from which macros it has been expanded from to prevent recursion
        for tok in tokens:
            if not hasattr(tok, &#39;expanded_from&#39;):
                tok.expanded_from = []
        i = 0
        #print &#34;*** EXPAND MACROS in&#34;, &#34;&#34;.join([t.value for t in tokens]), &#34;expanding_from=&#34;, expanding_from
        #print tokens
        #print [(t.value, t.expanded_from) for t in tokens]
        while i &lt; len(tokens):
            t = tokens[i]
            if self.linemacrodepth == 0:
                self.linemacro = t.lineno
            self.linemacrodepth = self.linemacrodepth + 1
            if t.type == self.t_ID:
                if t.value in self.macros and t.value not in t.expanded_from and t.value not in expanding_from:
                    # Yes, we found a macro match
                    m = self.macros[t.value]
                    if m.arglist is None:
                        # A simple macro
                        rep = [copy.copy(_x) for _x in m.value]
                        ex = self.expand_macros(rep, expanding_from + [t.value])
                        #print &#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:i+1]
                        for e in ex:
                            e.source = t.source
                            e.lineno = t.lineno
                            if not hasattr(e, &#39;expanded_from&#39;):
                                e.expanded_from = []
                            e.expanded_from.append(t.value)
                        tokens[i:i+1] = ex
                    else:
                        # A macro with arguments
                        j = i + 1
                        while j &lt; len(tokens) and (tokens[j].type in self.t_WS or tokens[j].type in self.t_COMMENT):
                            j += 1
                        # A function like macro without an invocation list is to be ignored
                        if j == len(tokens) or tokens[j].value != &#39;(&#39;:
                            i = j
                        else:
                            tokcount,args,positions = self.collect_args(tokens[j:], True)
                            if tokcount == 0:
                                # Unclosed parameter list, just bail out
                                break
                            if (not m.variadic
                                # A no arg or single arg consuming macro is permitted to be expanded with nothing
                                and (args != [[]] or len(m.arglist) &gt; 1)
                                and len(args) !=  len(m.arglist)):
                                self.on_error(t.source,t.lineno,&#34;Macro %s requires %d arguments but was passed %d&#34; % (t.value,len(m.arglist),len(args)))
                                i = j + tokcount
                            elif m.variadic and len(args) &lt; len(m.arglist)-1:
                                if len(m.arglist) &gt; 2:
                                    self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d arguments&#34; % (t.value, len(m.arglist)-1))
                                else:
                                    self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d argument&#34; % (t.value, len(m.arglist)-1))
                                i = j + tokcount
                            else:
                                if m.variadic:
                                    if len(args) == len(m.arglist)-1:
                                        args.append([])
                                    else:
                                        args[len(m.arglist)-1] = tokens[j+positions[len(m.arglist)-1]:j+tokcount-1]
                                        del args[len(m.arglist):]
                                else:
                                    # If we called a single arg macro with empty, fake extend args
                                    while len(args) &lt; len(m.arglist):
                                        args.append([])
                                        
                                # Get macro replacement text
                                rep = self.macro_expand_args(m,args)
                                ex = self.expand_macros(rep, expanding_from + [t.value])
                                for e in ex:
                                    e.source = t.source
                                    e.lineno = t.lineno
                                    if not hasattr(e, &#39;expanded_from&#39;):
                                        e.expanded_from = []
                                    e.expanded_from.append(t.value)
                                # A non-conforming extension implemented by the GCC and clang preprocessors
                                # is that an expansion of a macro with arguments where the following token is
                                # an identifier inserts a space between the expansion and the identifier. This
                                # differs from Boost.Wave incidentally (see https://github.com/ned14/pcpp/issues/29)
                                if len(tokens) &gt; j+tokcount and tokens[j+tokcount].type in self.t_ID:
                                    #print(&#34;*** token after expansion is&#34;, tokens[j+tokcount])
                                    newtok = copy.copy(tokens[j+tokcount])
                                    newtok.type = self.t_SPACE
                                    newtok.value = &#39; &#39;
                                    ex.append(newtok)
                                #print(&#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:j+tokcount])
                                tokens[i:j+tokcount] = ex
                    self.linemacrodepth = self.linemacrodepth - 1
                    if self.linemacrodepth == 0:
                        self.linemacro = 0
                    continue
                elif self.expand_linemacro and t.value == &#39;__LINE__&#39;:
                    t.type = self.t_INTEGER
                    t.value = self.t_INTEGER_TYPE(self.linemacro)
                elif self.expand_countermacro and t.value == &#39;__COUNTER__&#39;:
                    t.type = self.t_INTEGER
                    t.value = self.t_INTEGER_TYPE(self.countermacro)
                    self.countermacro += 1
                
            i += 1
            self.linemacrodepth = self.linemacrodepth - 1
            if self.linemacrodepth == 0:
                self.linemacro = 0
        return tokens

    # ----------------------------------------------------------------------    
    # evalexpr()
    # 
    # Evaluate an expression token sequence for the purposes of evaluating
    # integral expressions.
    # ----------------------------------------------------------------------

    def evalexpr(self,tokens):
        &#34;&#34;&#34;Evaluate an expression token sequence for the purposes of evaluating
        integral expressions.&#34;&#34;&#34;
        if not tokens:
            self.on_error(&#39;unknown&#39;, 0, &#34;Empty expression&#34;)
            return (0, None)
        # tokens = tokenize(line)
        # Search for defined macros
        evalfuncts = {&#39;defined&#39; : lambda x: True}
        evalvars = {}
        def replace_defined(tokens):
            i = 0
            while i &lt; len(tokens):
                if tokens[i].type == self.t_ID and tokens[i].value == &#39;defined&#39;:
                    j = i + 1
                    needparen = False
                    result = &#34;0L&#34;
                    while j &lt; len(tokens):
                        if tokens[j].type in self.t_WS:
                            j += 1
                            continue
                        elif tokens[j].type == self.t_ID:
                            if tokens[j].value in self.macros:
                                result = &#34;1L&#34;
                            else:
                                repl = self.on_unknown_macro_in_defined_expr(tokens[j])
                                if repl is None:
                                    # Add this identifier to a dictionary of variables
                                    evalvars[tokens[j].value] = 0
                                    result = &#39;defined(&#39;+tokens[j].value+&#39;)&#39;
                                else:
                                    result = &#34;1L&#34; if repl else &#34;0L&#34;
                            if not needparen: break
                        elif tokens[j].value == &#39;(&#39;:
                            needparen = True
                        elif tokens[j].value == &#39;)&#39;:
                            break
                        else:
                            self.on_error(tokens[i].source,tokens[i].lineno,&#34;Malformed defined()&#34;)
                        j += 1
                    if result.startswith(&#39;defined&#39;):
                        tokens[i].type = self.t_ID
                        tokens[i].value = result
                    else:
                        tokens[i].type = self.t_INTEGER
                        tokens[i].value = self.t_INTEGER_TYPE(result)
                    del tokens[i+1:j+1]
                i += 1
            return tokens
        # Replace any defined(macro) before macro expansion
        tokens = replace_defined(tokens)
        tokens = self.expand_macros(tokens)
        # Replace any defined(macro) after macro expansion
        tokens = replace_defined(tokens)
        if not tokens:
            return (0, None)
        for i,t in enumerate(tokens):
            if t.type == self.t_ID:
                repl = self.on_unknown_macro_in_expr(copy.copy(t))
                if repl is None:
                    # Add this identifier to a dictionary of variables
                    evalvars[t.value] = 0
                else:
                    tokens[i] = t = repl
            if t.type == self.t_INTEGER:
                tokens[i] = copy.copy(t)
                # Strip off any trailing suffixes
                tokens[i].value = str(tokens[i].value)
                while tokens[i].value[-1] not in &#34;0123456789abcdefABCDEF&#34;:
                    tokens[i].value = tokens[i].value[:-1]
                if sys.version_info.major &gt;= 3:
                    if len(tokens[i].value) &gt; 1 and tokens[i].value[0] == &#39;0&#39; and tokens[i].value[1] &gt;= &#39;0&#39; and tokens[i].value[1] &lt;= &#39;7&#39;:
                        tokens[i].value = &#39;0o&#39; + tokens[i].value[1:]
            elif t.type == self.t_CHAR:
                tokens[i] = copy.copy(t)
                # Strip off any leading prefixes
                tokens[i].value = str(tokens[i].value)
                while tokens[i].value[0] != &#39;\&#39;&#39;:
                    tokens[i].value = tokens[i].value[1:]
                # Strip off quotes
                strip_value = tokens[i].value.strip(&#39;\&#39;&#39;)
                # Unescape character
                unescape_value = codecs.getdecoder(&#34;unicode_escape&#34;)(strip_value)[0]
                tokens[i].value = ord(unescape_value)
            elif t.type == self.t_COLON:
                # Find the expression before the colon
                cs = ce = i - 1
                while cs &gt; 0 and tokens[cs].type in self.t_WS:
                    cs -= 1
                if cs &gt; 0 and tokens[cs].value == &#39;)&#39;:
                    cs -= 1
                    brackets = 1
                    while cs &gt; 0:
                        if tokens[cs].value == &#39;)&#39;:
                            brackets += 1
                        elif tokens[cs].value == &#39;(&#39;:
                            brackets -= 1
                            if brackets == 0:
                                break
                        cs -= 1
                while cs &gt; 0 and tokens[cs].type != self.t_TERNARY:
                    cs -= 1
                ternary = cs
                cs += 1
                # Find the expression before the ternary
                es = ee = ternary - 1
                while es &gt; 0 and tokens[es].type in self.t_WS:
                    es -= 1
                if es &gt; 0 and tokens[es].value == &#39;)&#39;:
                    es -= 1
                    brackets = 1
                    while es &gt; 0:
                        if tokens[es].value == &#39;)&#39;:
                            brackets += 1
                        elif tokens[es].value == &#39;(&#39;:
                            brackets -= 1
                            if brackets == 0:
                                break
                        es -= 1
                else:
                    while es &gt; 0 and tokens[es].type not in self.t_WS:
                        es -= 1
                    if tokens[es].value == &#39;(&#39;:
                        es += 1
                # Swap the pre-ternary and post-ternary expressions
                tokens[ternary].value = &#39; if &#39;
                tokens[i].value = &#39; else &#39;
                # Note this is identical length
                tokens = tokens[:es] + tokens[cs:ce+1] + tokens[ternary:ternary+1] + tokens[es:ee+1] + tokens[i:]
        
        expr = origexpr = &#34;&#34;.join([str(x.value) for x in tokens if x.type not in self.t_COMMENT])
        expr = expr.replace(&#34;&amp;&amp;&#34;,&#34; and &#34;)
        expr = expr.replace(&#34;||&#34;,&#34; or &#34;)
        expr = expr.replace(&#34;!=&#34;,&#34; &lt;&gt; &#34;)
        expr = expr.replace(&#34;!&#34;,&#34; not &#34;)
        expr = expr.replace(&#34; &lt;&gt; &#34;, &#34; != &#34;)
        try:
            result = int(eval(expr, evalfuncts, evalvars))
        except Exception:
            print(&#34;%s:%d&#34; % (tokens[0].source,tokens[0].lineno), &#34;warning: couldn&#39;t evaluate expression due to&#34;, traceback.format_exc()
            + &#34;\nConverted expression was&#34;, expr, &#34;with evalvars =&#34;, repr(evalvars))
            result = 0
        return (result, tokens) if evalvars else (result, None)

    # ----------------------------------------------------------------------
    # parsegen()
    #
    # Parse an input string
    # ----------------------------------------------------------------------
    def parsegen(self,input,source=None,abssource=None):
        &#34;&#34;&#34;Parse an input string&#34;&#34;&#34;
        rewritten_source = source
        if abssource:
            rewritten_source = abssource
            for rewrite in self.rewrite_paths:
                temp = re.sub(rewrite[0], rewrite[1], rewritten_source)
                if temp != abssource:
                    rewritten_source = temp
                    if os.sep != &#39;/&#39;:
                        rewritten_source = rewritten_source.replace(os.sep, &#39;/&#39;)
                    break

        # Replace trigraph sequences
        t = trigraph(input)
        lines = self.group_lines(t, rewritten_source)

        if not source:
            source = &#34;&#34;
        if not rewritten_source:
            rewritten_source = &#34;&#34;
            
        my_include_times_idx = len(self.include_times)
        self.include_times.append(FileInclusionTime(self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None, source, abssource, self.include_depth))
        self.include_depth += 1
        my_include_time_begin = clock()
        if self.expand_filemacro:
            self.define(&#34;__FILE__ \&#34;%s\&#34;&#34; % rewritten_source)

        self.source = abssource
        chunk = []
        enable = True
        iftrigger = False
        ifpassthru = False
        class ifstackentry(object):
            def __init__(self,enable,iftrigger,ifpassthru,startlinetoks):
                self.enable = enable
                self.iftrigger = iftrigger
                self.ifpassthru = ifpassthru
                self.rewritten = False
                self.startlinetoks = startlinetoks
        ifstack = []
        # True until any non-whitespace output or anything with effects happens.
        at_front_of_file = True
        # True if auto pragma once still a possibility for this #include
        auto_pragma_once_possible = self.auto_pragma_once_enabled
        # =(MACRO, 0) means #ifndef MACRO or #if !defined(MACRO) seen, =(MACRO,1) means #define MACRO seen
        include_guard = None
        self.on_potential_include_guard(None)

        for x in lines:
            all_whitespace = True
            skip_auto_pragma_once_possible_check = False
            # Handle comments
            for i,tok in enumerate(x):
                if tok.type in self.t_COMMENT:
                    if not self.on_comment(tok):
                        if tok.type == self.t_COMMENT1:
                            tok.value = &#39; &#39;
                        elif tok.type == self.t_COMMENT2:
                            tok.value = &#39;\n&#39;
                        tok.type = &#39;CPP_WS&#39;
            # Skip over whitespace
            for i,tok in enumerate(x):
                if tok.type not in self.t_WS and tok.type not in self.t_COMMENT:
                    all_whitespace = False
                    break
            output_and_expand_line = True
            output_unexpanded_line = False
            if tok.value == &#39;#&#39;:
                precedingtoks = [ tok ]
                output_and_expand_line = False
                try:
                    # Preprocessor directive      
                    i += 1
                    while i &lt; len(x) and x[i].type in self.t_WS:
                        precedingtoks.append(x[i])
                        i += 1                    
                    dirtokens = self.tokenstrip(x[i:])
                    if dirtokens:
                        name = dirtokens[0].value
                        args = self.tokenstrip(dirtokens[1:])
                    
                        if self.debugout is not None:
                            print(&#34;%d:%d:%d %s:%d #%s %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, dirtokens[0].value, &#34;&#34;.join([tok.value for tok in args])), file = self.debugout)
                            #print(ifstack)

                        handling = self.on_directive_handle(dirtokens[0],args,ifpassthru,precedingtoks)
                        assert handling == True or handling == None
                    else:
                        name = &#34;&#34;
                        args = []
                        raise OutputDirective(Action.IgnoreAndRemove)
                        
                    if name == &#39;define&#39;:
                        at_front_of_file = False
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            if include_guard and include_guard[1] == 0:
                                if include_guard[0] == args[0].value and len(args) == 1:
                                    include_guard = (args[0].value, 1)
                                    # If ifpassthru is only turned on due to this include guard, turn it off
                                    if ifpassthru and not ifstack[-1].ifpassthru:
                                        ifpassthru = False
                            self.define(args)
                            if self.debugout is not None:
                                print(&#34;%d:%d:%d %s:%d      %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, repr(self.macros[args[0].value])), file = self.debugout)
                            if handling is None:
                                for tok in x:
                                    yield tok
                    elif name == &#39;include&#39;:
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            oldfile = self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None
                            for tok in self.include(args):
                                yield tok
                            if oldfile is not None:
                                self.macros[&#39;__FILE__&#39;] = oldfile
                            self.source = abssource
                    elif name == &#39;undef&#39;:
                        at_front_of_file = False
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            self.undef(args)
                            if handling is None:
                                for tok in x:
                                    yield tok
                    elif name == &#39;ifdef&#39;:
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            ifpassthru = False
                            if not args[0].value in self.macros:
                                res = self.on_unknown_macro_in_defined_expr(args[0])
                                if res is None:
                                    ifpassthru = True
                                    ifstack[-1].rewritten = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                elif res is True:
                                    iftrigger = True
                                else:
                                    enable = False
                                    iftrigger = False
                            else:
                                iftrigger = True
                    elif name == &#39;ifndef&#39;:
                        if not ifstack and at_front_of_file:
                            self.on_potential_include_guard(args[0].value)
                            include_guard = (args[0].value, 0)
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            ifpassthru = False
                            if args[0].value in self.macros:
                                enable = False
                                iftrigger = False
                            else:
                                res = self.on_unknown_macro_in_defined_expr(args[0])
                                if res is None:
                                    ifpassthru = True
                                    ifstack[-1].rewritten = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                elif res is True:
                                    enable = False
                                    iftrigger = False
                                else:
                                    iftrigger = True
                    elif name == &#39;if&#39;:
                        if not ifstack and at_front_of_file:
                            if args[0].value == &#39;!&#39; and args[1].value == &#39;defined&#39;:
                                n = 2
                                if args[n].value == &#39;(&#39;: n += 1
                                self.on_potential_include_guard(args[n].value)
                                include_guard = (args[n].value, 0)
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            iftrigger = False
                            ifpassthru = False
                            result, rewritten = self.evalexpr(args)
                            if rewritten is not None:
                                x = x[:i+2] + rewritten + [x[-1]]
                                x[i+1] = copy.copy(x[i+1])
                                x[i+1].type = self.t_SPACE
                                x[i+1].value = &#39; &#39;
                                ifpassthru = True
                                ifstack[-1].rewritten = True
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                            if not result:
                                enable = False
                            else:
                                iftrigger = True
                    elif name == &#39;elif&#39;:
                        at_front_of_file = False
                        if ifstack:
                            if ifstack[-1].enable:     # We only pay attention if outer &#34;if&#34; allows this
                                if enable and not ifpassthru:         # If already true, we flip enable False
                                    enable = False
                                elif not iftrigger:   # If False, but not triggered yet, we&#39;ll check expression
                                    result, rewritten = self.evalexpr(args)
                                    if rewritten is not None:
                                        enable = True
                                        if not ifpassthru:
                                            # This is a passthru #elif after a False #if, so convert to an #if
                                            x[i].value = &#39;if&#39;
                                        x = x[:i+2] + rewritten + [x[-1]]
                                        x[i+1] = copy.copy(x[i+1])
                                        x[i+1].type = self.t_SPACE
                                        x[i+1].value = &#39; &#39;
                                        ifpassthru = True
                                        ifstack[-1].rewritten = True
                                        raise OutputDirective(Action.IgnoreAndPassThrough)
                                    if ifpassthru:
                                        # If this elif can only ever be true, simulate that
                                        if result:
                                            newtok = copy.copy(x[i+3])
                                            newtok.type = self.t_INTEGER
                                            newtok.value = self.t_INTEGER_TYPE(result)
                                            x = x[:i+2] + [newtok] + [x[-1]]
                                            raise OutputDirective(Action.IgnoreAndPassThrough)
                                        # Otherwise elide
                                        enable = False
                                    elif result:
                                        enable  = True
                                        iftrigger = True
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #elif&#34;)
                            
                    elif name == &#39;else&#39;:
                        at_front_of_file = False
                        if ifstack:
                            if ifstack[-1].enable:
                                if ifpassthru:
                                    enable = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                if enable:
                                    enable = False
                                elif not iftrigger:
                                    enable = True
                                    iftrigger = True
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #else&#34;)

                    elif name == &#39;endif&#39;:
                        at_front_of_file = False
                        if ifstack:
                            oldifstackentry = ifstack.pop()
                            enable = oldifstackentry.enable
                            iftrigger = oldifstackentry.iftrigger
                            ifpassthru = oldifstackentry.ifpassthru
                            if self.debugout is not None:
                                print(&#34;%d:%d:%d %s:%d      (%s:%d %s)&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno,
                                    oldifstackentry.startlinetoks[0].source, oldifstackentry.startlinetoks[0].lineno, &#34;&#34;.join([n.value for n in oldifstackentry.startlinetoks])), file = self.debugout)
                            skip_auto_pragma_once_possible_check = True
                            if oldifstackentry.rewritten:
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #endif&#34;)
                    elif name == &#39;pragma&#39; and args[0].value == &#39;once&#39;:
                        if enable:
                            self.include_once[self.source] = None
                    elif enable:
                        # Unknown preprocessor directive
                        output_unexpanded_line = (self.on_directive_unknown(dirtokens[0], args, ifpassthru, precedingtoks) is None)

                except OutputDirective as e:
                    if e.action == Action.IgnoreAndPassThrough:
                        output_unexpanded_line = True
                    elif e.action == Action.IgnoreAndRemove:
                        pass
                    else:
                        assert False

            # If there is ever any non-whitespace output outside an include guard, auto pragma once is not possible
            if not skip_auto_pragma_once_possible_check and auto_pragma_once_possible and not ifstack and not all_whitespace:
                auto_pragma_once_possible = False
                if self.debugout is not None:
                    print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is not entirely wrapped in an include guard macro, disabling auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, x[0].source, x[0].lineno, self.source), file = self.debugout)
                
            if output_and_expand_line or output_unexpanded_line:
                if not all_whitespace:
                    at_front_of_file = False

                # Normal text
                if enable:
                    if output_and_expand_line:
                        chunk.extend(x)
                    elif output_unexpanded_line:
                        for tok in self.expand_macros(chunk):
                            yield tok
                        chunk = []
                        for tok in x:
                            yield tok
                else:
                    # Need to extend with the same number of blank lines
                    i = 0
                    while i &lt; len(x):
                        if x[i].type not in self.t_WS:
                            del x[i]
                        else:
                            i += 1
                    chunk.extend(x)

        for tok in self.expand_macros(chunk):
            yield tok
        chunk = []
        for i in ifstack:
            self.on_error(i.startlinetoks[0].source, i.startlinetoks[0].lineno, &#34;Unterminated &#34; + &#34;&#34;.join([n.value for n in i.startlinetoks]))
        if auto_pragma_once_possible and include_guard and include_guard[1] == 1:
            if self.debugout is not None:
                print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is entirely wrapped in an include guard macro called %s, auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, self.source, 0, self.source, include_guard[0]), file = self.debugout)
            self.include_once[self.source] = include_guard[0]
        elif self.auto_pragma_once_enabled and self.source not in self.include_once:
            if self.debugout is not None:
                print(&#34;%d:%d:%d %s:%d Did not auto apply #pragma once to this file due to auto_pragma_once_possible=%d, include_guard=%s&#34; % (enable, iftrigger, ifpassthru, self.source, 0, auto_pragma_once_possible, repr(include_guard)), file = self.debugout)
        my_include_time_end = clock()
        self.include_times[my_include_times_idx].elapsed = my_include_time_end - my_include_time_begin
        self.include_depth -= 1

    # ----------------------------------------------------------------------
    # include()
    #
    # Implementation of file-inclusion
    # ----------------------------------------------------------------------

    def include(self,tokens):
        &#34;&#34;&#34;Implementation of file-inclusion&#34;&#34;&#34;
        # Try to extract the filename and then process an include file
        if not tokens:
            return
        if tokens:
            if tokens[0].value != &#39;&lt;&#39; and tokens[0].type != self.t_STRING:
                tokens = self.tokenstrip(self.expand_macros(tokens))

            is_system_include = False
            if tokens[0].value == &#39;&lt;&#39;:
                is_system_include = True
                # Include &lt;...&gt;
                i = 1
                while i &lt; len(tokens):
                    if tokens[i].value == &#39;&gt;&#39;:
                        break
                    i += 1
                else:
                    self.on_error(tokens[0].source,tokens[0].lineno,&#34;Malformed #include &lt;...&gt;&#34;)
                    return
                filename = &#34;&#34;.join([x.value for x in tokens[1:i]])
                # Search only formally specified paths
                path = self.path
            elif tokens[0].type == self.t_STRING:
                filename = tokens[0].value[1:-1]
                # Search from each nested include file, as well as formally specified paths
                path = self.temp_path + self.path
            else:
                p = self.on_include_not_found(True,False,self.temp_path[0] if self.temp_path else &#39;&#39;,tokens[0].value)
                assert p is None
                return
        if not path:
            path = [&#39;&#39;]
        while True:
            #print path
            for p in path:
                iname = os.path.join(p,filename)
                fulliname = os.path.abspath(iname)
                if fulliname in self.include_once:
                    if self.debugout is not None:
                        print(&#34;x:x:x x:x #include \&#34;%s\&#34; skipped as already seen&#34; % (fulliname), file = self.debugout)
                    return
                try:
                    ih = self.on_file_open(is_system_include,fulliname)
                    data = ih.read()
                    ih.close()
                    dname = os.path.dirname(fulliname)
                    if dname:
                        self.temp_path.insert(0,dname)
                    for tok in self.parsegen(data,filename,fulliname):
                        yield tok
                    if dname:
                        del self.temp_path[0]
                    return
                except IOError:
                    pass
            else:
                p = self.on_include_not_found(False,is_system_include,self.temp_path[0] if self.temp_path else &#39;&#39;,filename)
                assert p is not None
                path.append(p)

    # ----------------------------------------------------------------------
    # define()
    #
    # Define a new macro
    # ----------------------------------------------------------------------

    def define(self,tokens):
        &#34;&#34;&#34;Define a new macro&#34;&#34;&#34;
        if isinstance(tokens,STRING_TYPES):
            tokens = self.tokenize(tokens)
        else:
            tokens = [copy.copy(tok) for tok in tokens]
        def add_macro(self, name, macro):
            macro.source = name.source
            macro.lineno = name.lineno
            self.macros[name.value] = macro

        linetok = tokens
        try:
            name = linetok[0]
            if len(linetok) &gt; 1:
                mtype = linetok[1]
            else:
                mtype = None
            if not mtype:
                m = Macro(name.value,[])
                add_macro(self, name, m)
            elif mtype.type in self.t_WS:
                # A normal macro
                m = Macro(name.value,self.tokenstrip(linetok[2:]))
                add_macro(self, name, m)
            elif mtype.value == &#39;(&#39;:
                # A macro with arguments
                tokcount, args, positions = self.collect_args(linetok[1:])
                variadic = False
                for a in args:
                    if variadic:
                        self.on_error(name.source,name.lineno,&#34;No more arguments may follow a variadic argument&#34;)
                        break
                    astr = &#34;&#34;.join([str(_i.value) for _i in a])
                    if astr == &#34;...&#34;:
                        variadic = True
                        a[0].type = self.t_ID
                        a[0].value = &#39;__VA_ARGS__&#39;
                        variadic = True
                        del a[1:]
                        continue
                    elif astr[-3:] == &#34;...&#34; and a[0].type == self.t_ID:
                        variadic = True
                        del a[1:]
                        # If, for some reason, &#34;.&#34; is part of the identifier, strip off the name for the purposes
                        # of macro expansion
                        if a[0].value[-3:] == &#39;...&#39;:
                            a[0].value = a[0].value[:-3]
                        continue
                    # Empty arguments are permitted
                    if len(a) == 0 and len(args) == 1:
                        continue
                    if len(a) &gt; 1 or a[0].type != self.t_ID:
                        self.on_error(a[0].source,a[0].lineno,&#34;Invalid macro argument&#34;)
                        break
                else:
                    mvalue = self.tokenstrip(linetok[1+tokcount:])
                    i = 0
                    while i &lt; len(mvalue):
                        if i+1 &lt; len(mvalue):
                            if mvalue[i].type in self.t_WS and mvalue[i+1].value == &#39;##&#39;:
                                del mvalue[i]
                                continue
                            elif mvalue[i].value == &#39;##&#39; and mvalue[i+1].type in self.t_WS:
                                del mvalue[i+1]
                        i += 1
                    m = Macro(name.value,mvalue,[x[0].value for x in args] if args != [[]] else [],variadic)
                    self.macro_prescan(m)
                    add_macro(self, name, m)
            else:
                self.on_error(name.source,name.lineno,&#34;Bad macro definition&#34;)
        #except LookupError:
        #    print(&#34;Bad macro definition&#34;)
        except:
            raise

    # ----------------------------------------------------------------------
    # undef()
    #
    # Undefine a macro
    # ----------------------------------------------------------------------

    def undef(self,tokens):
        &#34;&#34;&#34;Undefine a macro&#34;&#34;&#34;
        if isinstance(tokens,STRING_TYPES):
            tokens = self.tokenize(tokens)
        id = tokens[0].value
        try:
            del self.macros[id]
        except LookupError:
            pass

    # ----------------------------------------------------------------------
    # parse()
    #
    # Parse input text.
    # ----------------------------------------------------------------------
    def parse(self,input,source=None,ignore={}):
        &#34;&#34;&#34;Parse input text.&#34;&#34;&#34;
        if isinstance(input, FILE_TYPES):
            if source is None:
                source = input.name
            input = input.read()
        self.ignore = ignore
        self.parser = self.parsegen(input,source,os.path.abspath(source) if source else None)
        if source is not None:
            dname = os.path.dirname(source)
            self.temp_path.insert(0,dname)
        
    # ----------------------------------------------------------------------
    # token()
    #
    # Method to return individual tokens
    # ----------------------------------------------------------------------
    def token(self):
        &#34;&#34;&#34;Method to return individual tokens&#34;&#34;&#34;
        try:
            while True:
                tok = next(self.parser)
                if tok.type not in self.ignore:
                    return tok
        except StopIteration:
            self.parser = None
            return None
            
    def write(self, oh=sys.stdout):
        &#34;&#34;&#34;Calls token() repeatedly, expanding tokens to their text and writing to the file like stream oh&#34;&#34;&#34;
        lastlineno = 0
        lastsource = None
        done = False
        blanklines = 0
        while not done:
            emitlinedirective = False
            toks = []
            all_ws = True
            # Accumulate a line
            while not done:
                tok = self.token()
                if not tok:
                    done = True
                    break
                toks.append(tok)
                if tok.value and tok.value[0] == &#39;\n&#39;:
                    break
                if tok.type not in self.t_WS:
                    all_ws = False
            if not toks:
                break
            if all_ws:
                # Remove preceding whitespace so it becomes just a LF
                if len(toks) &gt; 1:
                    tok = toks[-1]
                    toks = [ tok ]
                blanklines += toks[0].value.count(&#39;\n&#39;)
                continue
            # The line in toks is not all whitespace
            emitlinedirective = (blanklines &gt; 6) and self.line_directive is not None
            if hasattr(toks[0], &#39;source&#39;):
                if lastsource is None:
                    if toks[0].source is not None:
                        emitlinedirective = True
                    lastsource = toks[0].source
                elif lastsource != toks[0].source:
                    emitlinedirective = True
                    lastsource = toks[0].source
            # Replace consecutive whitespace in output with a single space except at any indent
            first_ws = None
            for n in xrange(len(toks)-1, -1, -1):
                tok = toks[n]
                if first_ws is None:
                    if tok.type in self.t_SPACE or len(tok.value) == 0:
                        first_ws = n
                else:
                    if tok.type not in self.t_SPACE and len(tok.value) &gt; 0:
                        m = n + 1
                        while m != first_ws:
                            del toks[m]
                            first_ws -= 1
                        first_ws = None
                        if self.compress &gt; 0:
                            # Collapse a token of many whitespace into single
                            if toks[m].value and toks[m].value[0] == &#39; &#39;:
                                toks[m].value = &#39; &#39;
            if not self.compress &gt; 1 and not emitlinedirective:
                newlinesneeded = toks[0].lineno - lastlineno - 1
                if newlinesneeded &gt; 6 and self.line_directive is not None:
                    emitlinedirective = True
                else:
                    while newlinesneeded &gt; 0:
                        oh.write(&#39;\n&#39;)
                        newlinesneeded -= 1
            lastlineno = toks[0].lineno
            # Account for those newlines in a multiline comment
            if emitlinedirective and self.line_directive is not None:
                oh.write(self.line_directive + &#39; &#39; + str(lastlineno) + (&#39;&#39; if lastsource is None else (&#39; &#34;&#39; + lastsource + &#39;&#34;&#39; )) + &#39;\n&#39;)
            for tok in toks:
                if tok.type == self.t_COMMENT1:
                    lastlineno += tok.value.count(&#39;\n&#39;)
            blanklines = 0
            #print toks[0].lineno, 
            for tok in toks:
                #print tok.value,
                oh.write(tok.value)
            #print &#39;&#39;

if __name__ == &#34;__main__&#34;:
    import doctest
    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pcpp.preprocessor.Action"><code class="flex name class">
<span>class <span class="ident">Action</span></span>
</code></dt>
<dd>
<section class="desc"><p>What kind of abort processing to do in OutputDirective</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Action(object):
    &#34;&#34;&#34;What kind of abort processing to do in OutputDirective&#34;&#34;&#34;
    IgnoreAndPassThrough = 0
    &#34;&#34;&#34;Abort processing (don&#39;t execute), but pass the directive through to output&#34;&#34;&#34;
    IgnoreAndRemove = 1
    &#34;&#34;&#34;Abort processing (don&#39;t execute), and remove from output&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pcpp.preprocessor.Action.IgnoreAndPassThrough"><code class="name">var <span class="ident">IgnoreAndPassThrough</span></code></dt>
<dd>
<section class="desc"><p>Abort processing (don't execute), but pass the directive through to output</p></section>
</dd>
<dt id="pcpp.preprocessor.Action.IgnoreAndRemove"><code class="name">var <span class="ident">IgnoreAndRemove</span></code></dt>
<dd>
<section class="desc"><p>Abort processing (don't execute), and remove from output</p></section>
</dd>
</dl>
</dd>
<dt id="pcpp.preprocessor.OutputDirective"><code class="flex name class">
<span>class <span class="ident">OutputDirective</span></span>
<span>(</span><span><small>ancestors:</small> builtins.Exception, builtins.BaseException)</span>
</code></dt>
<dd>
<section class="desc"><p>Raise this exception to abort processing of a preprocessor directive and
to instead output it as is into the output</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class OutputDirective(Exception):
    &#34;&#34;&#34;Raise this exception to abort processing of a preprocessor directive and
    to instead output it as is into the output&#34;&#34;&#34;
    def __init__(self, action):
        self.action = action</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pcpp.preprocessor.OutputDirective.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, action):
    self.action = action</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pcpp.preprocessor.Preprocessor"><code class="flex name class">
<span>class <span class="ident">Preprocessor</span></span>
<span>(</span><span><small>ancestors:</small> <a title="pcpp.preprocessor.PreprocessorHooks" href="#pcpp.preprocessor.PreprocessorHooks">PreprocessorHooks</a>)</span>
</code></dt>
<dd>
<section class="desc"><p>Override these in your subclass of Preprocessor to customise preprocessing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Preprocessor(PreprocessorHooks):    
    def __init__(self,lexer=None):
        super(Preprocessor, self).__init__()
        if lexer is None:
            lexer = lex.lex()
        self.lexer = lexer
        self.macros = { }
        self.path = []           # list of -I formal search paths for includes
        self.temp_path = []      # list of temporary search paths for includes
        self.rewrite_paths = [(re.escape(os.path.abspath(&#39;&#39;) + os.sep) + &#39;(.*)&#39;, &#39;\\1&#39;)]
        self.include_once = {}
        self.include_depth = 0
        self.include_times = []  # list of FileInclusionTime
        self.return_code = 0
        self.debugout = None
        self.auto_pragma_once_enabled = True
        self.line_directive = &#39;#line&#39;
        self.compress = False
        self.assume_encoding = None

        # Probe the lexer for selected tokens
        self.__lexprobe()

        tm = time.localtime()
        self.define(&#34;__DATE__ \&#34;%s\&#34;&#34; % time.strftime(&#34;%b %d %Y&#34;,tm))
        self.define(&#34;__TIME__ \&#34;%s\&#34;&#34; % time.strftime(&#34;%H:%M:%S&#34;,tm))
        self.define(&#34;__PCPP__ 1&#34;)
        self.expand_linemacro = True
        self.expand_filemacro = True
        self.expand_countermacro = True
        self.linemacro = 0
        self.linemacrodepth = 0
        self.countermacro = 0
        self.parser = None

    # -----------------------------------------------------------------------------
    # tokenize()
    #
    # Utility function. Given a string of text, tokenize into a list of tokens
    # -----------------------------------------------------------------------------

    def tokenize(self,text):
        &#34;&#34;&#34;Utility function. Given a string of text, tokenize into a list of tokens&#34;&#34;&#34;
        tokens = []
        self.lexer.input(text)
        while True:
            tok = self.lexer.token()
            if not tok: break
            tok.source = &#39;&#39;
            tokens.append(tok)
        return tokens

    # ----------------------------------------------------------------------
    # __lexprobe()
    #
    # This method probes the preprocessor lexer object to discover
    # the token types of symbols that are important to the preprocessor.
    # If this works right, the preprocessor will simply &#34;work&#34;
    # with any suitable lexer regardless of how tokens have been named.
    # ----------------------------------------------------------------------

    def __lexprobe(self):

        # Determine the token type for identifiers
        self.lexer.input(&#34;identifier&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;identifier&#34;:
            print(&#34;Couldn&#39;t determine identifier type&#34;)
        else:
            self.t_ID = tok.type

        # Determine the token type for integers
        self.lexer.input(&#34;12345&#34;)
        tok = self.lexer.token()
        if not tok or int(tok.value) != 12345:
            print(&#34;Couldn&#39;t determine integer type&#34;)
        else:
            self.t_INTEGER = tok.type
            self.t_INTEGER_TYPE = type(tok.value)

        # Determine the token type for character
        self.lexer.input(&#34;&#39;a&#39;&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;&#39;a&#39;&#34;:
            print(&#34;Couldn&#39;t determine character type&#34;)
        else:
            self.t_CHAR = tok.type
            
        # Determine the token type for strings enclosed in double quotes
        self.lexer.input(&#34;\&#34;filename\&#34;&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;\&#34;filename\&#34;&#34;:
            print(&#34;Couldn&#39;t determine string type&#34;)
        else:
            self.t_STRING = tok.type

        # Determine the token type for whitespace--if any
        self.lexer.input(&#34;  &#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;  &#34;:
            self.t_SPACE = None
        else:
            self.t_SPACE = tok.type

        # Determine the token type for newlines
        self.lexer.input(&#34;\n&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;\n&#34;:
            self.t_NEWLINE = None
            print(&#34;Couldn&#39;t determine token for newlines&#34;)
        else:
            self.t_NEWLINE = tok.type

        # Determine the token type for line continuations
        self.lexer.input(&#34;\\     \n&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;     &#34;:
            self.t_LINECONT = None
            print(&#34;Couldn&#39;t determine token for line continuations&#34;)
        else:
            self.t_LINECONT = tok.type

        self.t_WS = (self.t_SPACE, self.t_NEWLINE, self.t_LINECONT)

        self.lexer.input(&#34;##&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;##&#34;:
            print(&#34;Couldn&#39;t determine token for token pasting operator&#34;)
        else:
            self.t_DPOUND = tok.type

        self.lexer.input(&#34;?&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;?&#34;:
            print(&#34;Couldn&#39;t determine token for ternary operator&#34;)
        else:
            self.t_TERNARY = tok.type

        self.lexer.input(&#34;:&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;:&#34;:
            print(&#34;Couldn&#39;t determine token for ternary operator&#34;)
        else:
            self.t_COLON = tok.type

        self.lexer.input(&#34;/* comment */&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;/* comment */&#34;:
            print(&#34;Couldn&#39;t determine comment type&#34;)
        else:
            self.t_COMMENT1 = tok.type

        self.lexer.input(&#34;// comment&#34;)
        tok = self.lexer.token()
        if not tok or tok.value != &#34;// comment&#34;:
            print(&#34;Couldn&#39;t determine comment type&#34;)
        else:
            self.t_COMMENT2 = tok.type
            
        self.t_COMMENT = (self.t_COMMENT1, self.t_COMMENT2)

        # Check for other characters used by the preprocessor
        chars = [ &#39;&lt;&#39;,&#39;&gt;&#39;,&#39;#&#39;,&#39;##&#39;,&#39;\\&#39;,&#39;(&#39;,&#39;)&#39;,&#39;,&#39;,&#39;.&#39;]
        for c in chars:
            self.lexer.input(c)
            tok = self.lexer.token()
            if not tok or tok.value != c:
                print(&#34;Unable to lex &#39;%s&#39; required for preprocessor&#34; % c)

    # ----------------------------------------------------------------------
    # add_path()
    #
    # Adds a search path to the preprocessor.  
    # ----------------------------------------------------------------------

    def add_path(self,path):
        &#34;&#34;&#34;Adds a search path to the preprocessor. &#34;&#34;&#34;
        self.path.append(path)
        # If the search path being added is relative, or has a common ancestor to the
        # current working directory, add a rewrite to relativise includes from this
        # search path
        relpath = None
        try:
            relpath = os.path.relpath(path)
        except: pass
        if relpath is not None:
            self.rewrite_paths += [(re.escape(os.path.abspath(path) + os.sep) + &#39;(.*)&#39;, os.path.join(relpath, &#39;\\1&#39;))]


    # ----------------------------------------------------------------------
    # group_lines()
    #
    # Given an input string, this function splits it into lines.  Trailing whitespace
    # is removed. This function forms the lowest level of the preprocessor---grouping
    # text into a line-by-line format.
    # ----------------------------------------------------------------------

    def group_lines(self,input,abssource):
        r&#34;&#34;&#34;Given an input string, this function splits it into lines.  Trailing whitespace
        is removed. This function forms the lowest level of the preprocessor---grouping
        text into a line-by-line format.
        &#34;&#34;&#34;
        lex = self.lexer.clone()
        lines = [x.rstrip() for x in input.splitlines()]

        input = &#34;\n&#34;.join(lines)
        lex.input(input)
        lex.lineno = 1

        current_line = []
        while True:
            tok = lex.token()
            if not tok:
                break
            tok.source = abssource
            current_line.append(tok)
            if tok.type in self.t_WS and tok.value == &#39;\n&#39;:
                yield current_line
                current_line = []

        if current_line:
            nltok = copy.copy(current_line[-1])
            nltok.type = self.t_NEWLINE
            nltok.value = &#39;\n&#39;
            current_line.append(nltok)
            yield current_line

    # ----------------------------------------------------------------------
    # tokenstrip()
    # 
    # Remove leading/trailing whitespace tokens from a token list
    # ----------------------------------------------------------------------

    def tokenstrip(self,tokens):
        &#34;&#34;&#34;Remove leading/trailing whitespace tokens from a token list&#34;&#34;&#34;
        i = 0
        while i &lt; len(tokens) and tokens[i].type in self.t_WS:
            i += 1
        del tokens[:i]
        i = len(tokens)-1
        while i &gt;= 0 and tokens[i].type in self.t_WS:
            i -= 1
        del tokens[i+1:]
        return tokens


    # ----------------------------------------------------------------------
    # collect_args()
    #
    # Collects comma separated arguments from a list of tokens.   The arguments
    # must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
    # where tokencount is the number of tokens consumed, args is a list of arguments,
    # and positions is a list of integers containing the starting index of each
    # argument.  Each argument is represented by a list of tokens.
    #
    # When collecting arguments, leading and trailing whitespace is removed
    # from each argument.  
    #
    # This function properly handles nested parenthesis and commas---these do not
    # define new arguments.
    # ----------------------------------------------------------------------

    def collect_args(self,tokenlist,ignore_errors=False):
        &#34;&#34;&#34;Collects comma separated arguments from a list of tokens.   The arguments
        must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
        where tokencount is the number of tokens consumed, args is a list of arguments,
        and positions is a list of integers containing the starting index of each
        argument.  Each argument is represented by a list of tokens.
        
        When collecting arguments, leading and trailing whitespace is removed
        from each argument.  
        
        This function properly handles nested parenthesis and commas---these do not
        define new arguments.&#34;&#34;&#34;
        args = []
        positions = []
        current_arg = []
        nesting = 1
        tokenlen = len(tokenlist)
    
        # Search for the opening &#39;(&#39;.
        i = 0
        while (i &lt; tokenlen) and (tokenlist[i].type in self.t_WS):
            i += 1

        if (i &lt; tokenlen) and (tokenlist[i].value == &#39;(&#39;):
            positions.append(i+1)
        else:
            if not ignore_errors:
                self.on_error(tokenlist[0].source,tokenlist[0].lineno,&#34;Missing &#39;(&#39; in macro arguments&#34;)
            return 0, [], []

        i += 1

        while i &lt; tokenlen:
            t = tokenlist[i]
            if t.value == &#39;(&#39;:
                current_arg.append(t)
                nesting += 1
            elif t.value == &#39;)&#39;:
                nesting -= 1
                if nesting == 0:
                    args.append(self.tokenstrip(current_arg))
                    positions.append(i)
                    return i+1,args,positions
                current_arg.append(t)
            elif t.value == &#39;,&#39; and nesting == 1:
                args.append(self.tokenstrip(current_arg))
                positions.append(i+1)
                current_arg = []
            else:
                current_arg.append(t)
            i += 1
    
        # Missing end argument
        if not ignore_errors:
            self.on_error(tokenlist[-1].source,tokenlist[-1].lineno,&#34;Missing &#39;)&#39; in macro arguments&#34;)
        return 0, [],[]

    # ----------------------------------------------------------------------
    # macro_prescan()
    #
    # Examine the macro value (token sequence) and identify patch points
    # This is used to speed up macro expansion later on---we&#39;ll know
    # right away where to apply patches to the value to form the expansion
    # ----------------------------------------------------------------------
    
    def macro_prescan(self,macro):
        &#34;&#34;&#34;Examine the macro value (token sequence) and identify patch points
        This is used to speed up macro expansion later on---we&#39;ll know
        right away where to apply patches to the value to form the expansion&#34;&#34;&#34;
        macro.patch     = []             # Standard macro arguments 
        macro.str_patch = []             # String conversion expansion
        macro.var_comma_patch = []       # Variadic macro comma patch
        i = 0
        #print(&#34;BEFORE&#34;, macro.value)
        while i &lt; len(macro.value):
            if macro.value[i].type == self.t_ID and macro.value[i].value in macro.arglist:
                argnum = macro.arglist.index(macro.value[i].value)
                # Conversion of argument to a string
                j = i - 1
                while j &gt;= 0 and macro.value[j].type in self.t_WS:
                    j -= 1
                if j &gt;= 0 and macro.value[j].value == &#39;#&#39;:
                    macro.value[i] = copy.copy(macro.value[i])
                    macro.value[i].type = self.t_STRING
                    while i &gt; j:
                        del macro.value[j]
                        i -= 1
                    macro.str_patch.append((argnum,i))
                    continue
                # Concatenation
                elif (i &gt; 0 and macro.value[i-1].value == &#39;##&#39;):
                    macro.patch.append((&#39;t&#39;,argnum,i))
                    i += 1
                    continue
                elif ((i+1) &lt; len(macro.value) and macro.value[i+1].value == &#39;##&#39;):
                    macro.patch.append((&#39;t&#39;,argnum,i))
                    i += 1
                    continue
                # Standard expansion
                else:
                    macro.patch.append((&#39;e&#39;,argnum,i))
            elif macro.value[i].value == &#39;##&#39;:
                if macro.variadic and (i &gt; 0) and (macro.value[i-1].value == &#39;,&#39;) and \
                        ((i+1) &lt; len(macro.value)) and (macro.value[i+1].type == self.t_ID) and \
                        (macro.value[i+1].value == macro.vararg):
                    macro.var_comma_patch.append(i-1)
            i += 1
        macro.patch.sort(key=lambda x: x[2],reverse=True)
        #print(&#34;AFTER&#34;, macro.value)

    # ----------------------------------------------------------------------
    # macro_expand_args()
    #
    # Given a Macro and list of arguments (each a token list), this method
    # returns an expanded version of a macro.  The return value is a token sequence
    # representing the replacement macro tokens
    # ----------------------------------------------------------------------

    def macro_expand_args(self,macro,args):
        &#34;&#34;&#34;Given a Macro and list of arguments (each a token list), this method
        returns an expanded version of a macro.  The return value is a token sequence
        representing the replacement macro tokens&#34;&#34;&#34;
        # Make a copy of the macro token sequence
        rep = [copy.copy(_x) for _x in macro.value]

        # Make string expansion patches.  These do not alter the length of the replacement sequence
        str_expansion = {}
        for argnum, i in macro.str_patch:
            if argnum not in str_expansion:
                # Strip all non-space whitespace before stringization
                tokens = copy.copy(args[argnum])
                for j in xrange(len(tokens)):
                    if tokens[j].type in self.t_WS and tokens[j].type != self.t_LINECONT:
                        tokens[j].value = &#39; &#39;
                # Collapse all multiple whitespace too
                j = 0
                while j &lt; len(tokens) - 1:
                    if tokens[j].type in self.t_WS and tokens[j+1].type in self.t_WS:
                        del tokens[j+1]
                    else:
                        j += 1
                str = &#34;&#34;.join([x.value for x in tokens])
                str = str.replace(&#34;\\&#34;,&#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;)
                str_expansion[argnum] = &#39;&#34;&#39; + str + &#39;&#34;&#39;
            rep[i] = copy.copy(rep[i])
            rep[i].value = str_expansion[argnum]

        # Make the variadic macro comma patch.  If the variadic macro argument is empty, we get rid
        comma_patch = False
        if macro.variadic and not args[-1]:
            for i in macro.var_comma_patch:
                rep[i] = None
                comma_patch = True

        # Make all other patches.   The order of these matters.  It is assumed that the patch list
        # has been sorted in reverse order of patch location since replacements will cause the
        # size of the replacement sequence to expand from the patch point.
        
        expanded = { }
        #print(&#34;***&#34;, macro)
        #print(macro.patch)
        for ptype, argnum, i in macro.patch:
            # Concatenation.   Argument is left unexpanded
            if ptype == &#39;t&#39;:
                rep[i:i+1] = args[argnum]
            # Normal expansion.  Argument is macro expanded first
            elif ptype == &#39;e&#39;:
                if argnum not in expanded:
                    expanded[argnum] = self.expand_macros(args[argnum])
                rep[i:i+1] = expanded[argnum]

        # Get rid of removed comma if necessary
        if comma_patch:
            rep = [_i for _i in rep if _i]
            
        # Do a token concatenation pass, stitching any tokens separated by ## into a single token
        while len(rep) and rep[0].type == self.t_DPOUND:
            del rep[0]
        while len(rep) and rep[-1].type == self.t_DPOUND:
            del rep[-1]
        i = 1
        stitched = False
        while i &lt; len(rep) - 1:
            if rep[i].type == self.t_DPOUND:
                j = i + 1
                while rep[j].type == self.t_DPOUND:
                    j += 1
                rep[i-1] = copy.copy(rep[i-1])
                rep[i-1].type = None
                rep[i-1].value += rep[j].value
                while j &gt;= i:
                    del rep[i]
                    j -= 1
                stitched = True
            else:
                i += 1
        if stitched:
            # Stitched tokens will have unknown type, so figure those out now
            i = 0
            lex = self.lexer.clone()
            while i &lt; len(rep):
                if rep[i].type is None:
                    lex.input(rep[i].value)
                    toks = []
                    while True:
                        tok = lex.token()
                        if not tok:
                            break
                        toks.append(tok)
                    if len(toks) != 1:
                        # Split it once again
                        while len(toks) &gt; 1:
                            rep.insert(i+1, copy.copy(rep[i]))
                            rep[i+1].value = toks[-1].value
                            rep[i+1].type = toks[-1].type
                            toks.pop()
                        rep[i].value = toks[0].value
                        rep[i].type = toks[0].type
                    else:
                        rep[i].type = toks[0].type
                i += 1

        #print rep
        return rep


    # ----------------------------------------------------------------------
    # expand_macros()
    #
    # Given a list of tokens, this function performs macro expansion.
    # ----------------------------------------------------------------------

    def expand_macros(self,tokens,expanding_from=[]):
        &#34;&#34;&#34;Given a list of tokens, this function performs macro expansion.&#34;&#34;&#34;
        # Each token needs to track from which macros it has been expanded from to prevent recursion
        for tok in tokens:
            if not hasattr(tok, &#39;expanded_from&#39;):
                tok.expanded_from = []
        i = 0
        #print &#34;*** EXPAND MACROS in&#34;, &#34;&#34;.join([t.value for t in tokens]), &#34;expanding_from=&#34;, expanding_from
        #print tokens
        #print [(t.value, t.expanded_from) for t in tokens]
        while i &lt; len(tokens):
            t = tokens[i]
            if self.linemacrodepth == 0:
                self.linemacro = t.lineno
            self.linemacrodepth = self.linemacrodepth + 1
            if t.type == self.t_ID:
                if t.value in self.macros and t.value not in t.expanded_from and t.value not in expanding_from:
                    # Yes, we found a macro match
                    m = self.macros[t.value]
                    if m.arglist is None:
                        # A simple macro
                        rep = [copy.copy(_x) for _x in m.value]
                        ex = self.expand_macros(rep, expanding_from + [t.value])
                        #print &#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:i+1]
                        for e in ex:
                            e.source = t.source
                            e.lineno = t.lineno
                            if not hasattr(e, &#39;expanded_from&#39;):
                                e.expanded_from = []
                            e.expanded_from.append(t.value)
                        tokens[i:i+1] = ex
                    else:
                        # A macro with arguments
                        j = i + 1
                        while j &lt; len(tokens) and (tokens[j].type in self.t_WS or tokens[j].type in self.t_COMMENT):
                            j += 1
                        # A function like macro without an invocation list is to be ignored
                        if j == len(tokens) or tokens[j].value != &#39;(&#39;:
                            i = j
                        else:
                            tokcount,args,positions = self.collect_args(tokens[j:], True)
                            if tokcount == 0:
                                # Unclosed parameter list, just bail out
                                break
                            if (not m.variadic
                                # A no arg or single arg consuming macro is permitted to be expanded with nothing
                                and (args != [[]] or len(m.arglist) &gt; 1)
                                and len(args) !=  len(m.arglist)):
                                self.on_error(t.source,t.lineno,&#34;Macro %s requires %d arguments but was passed %d&#34; % (t.value,len(m.arglist),len(args)))
                                i = j + tokcount
                            elif m.variadic and len(args) &lt; len(m.arglist)-1:
                                if len(m.arglist) &gt; 2:
                                    self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d arguments&#34; % (t.value, len(m.arglist)-1))
                                else:
                                    self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d argument&#34; % (t.value, len(m.arglist)-1))
                                i = j + tokcount
                            else:
                                if m.variadic:
                                    if len(args) == len(m.arglist)-1:
                                        args.append([])
                                    else:
                                        args[len(m.arglist)-1] = tokens[j+positions[len(m.arglist)-1]:j+tokcount-1]
                                        del args[len(m.arglist):]
                                else:
                                    # If we called a single arg macro with empty, fake extend args
                                    while len(args) &lt; len(m.arglist):
                                        args.append([])
                                        
                                # Get macro replacement text
                                rep = self.macro_expand_args(m,args)
                                ex = self.expand_macros(rep, expanding_from + [t.value])
                                for e in ex:
                                    e.source = t.source
                                    e.lineno = t.lineno
                                    if not hasattr(e, &#39;expanded_from&#39;):
                                        e.expanded_from = []
                                    e.expanded_from.append(t.value)
                                # A non-conforming extension implemented by the GCC and clang preprocessors
                                # is that an expansion of a macro with arguments where the following token is
                                # an identifier inserts a space between the expansion and the identifier. This
                                # differs from Boost.Wave incidentally (see https://github.com/ned14/pcpp/issues/29)
                                if len(tokens) &gt; j+tokcount and tokens[j+tokcount].type in self.t_ID:
                                    #print(&#34;*** token after expansion is&#34;, tokens[j+tokcount])
                                    newtok = copy.copy(tokens[j+tokcount])
                                    newtok.type = self.t_SPACE
                                    newtok.value = &#39; &#39;
                                    ex.append(newtok)
                                #print(&#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:j+tokcount])
                                tokens[i:j+tokcount] = ex
                    self.linemacrodepth = self.linemacrodepth - 1
                    if self.linemacrodepth == 0:
                        self.linemacro = 0
                    continue
                elif self.expand_linemacro and t.value == &#39;__LINE__&#39;:
                    t.type = self.t_INTEGER
                    t.value = self.t_INTEGER_TYPE(self.linemacro)
                elif self.expand_countermacro and t.value == &#39;__COUNTER__&#39;:
                    t.type = self.t_INTEGER
                    t.value = self.t_INTEGER_TYPE(self.countermacro)
                    self.countermacro += 1
                
            i += 1
            self.linemacrodepth = self.linemacrodepth - 1
            if self.linemacrodepth == 0:
                self.linemacro = 0
        return tokens

    # ----------------------------------------------------------------------    
    # evalexpr()
    # 
    # Evaluate an expression token sequence for the purposes of evaluating
    # integral expressions.
    # ----------------------------------------------------------------------

    def evalexpr(self,tokens):
        &#34;&#34;&#34;Evaluate an expression token sequence for the purposes of evaluating
        integral expressions.&#34;&#34;&#34;
        if not tokens:
            self.on_error(&#39;unknown&#39;, 0, &#34;Empty expression&#34;)
            return (0, None)
        # tokens = tokenize(line)
        # Search for defined macros
        evalfuncts = {&#39;defined&#39; : lambda x: True}
        evalvars = {}
        def replace_defined(tokens):
            i = 0
            while i &lt; len(tokens):
                if tokens[i].type == self.t_ID and tokens[i].value == &#39;defined&#39;:
                    j = i + 1
                    needparen = False
                    result = &#34;0L&#34;
                    while j &lt; len(tokens):
                        if tokens[j].type in self.t_WS:
                            j += 1
                            continue
                        elif tokens[j].type == self.t_ID:
                            if tokens[j].value in self.macros:
                                result = &#34;1L&#34;
                            else:
                                repl = self.on_unknown_macro_in_defined_expr(tokens[j])
                                if repl is None:
                                    # Add this identifier to a dictionary of variables
                                    evalvars[tokens[j].value] = 0
                                    result = &#39;defined(&#39;+tokens[j].value+&#39;)&#39;
                                else:
                                    result = &#34;1L&#34; if repl else &#34;0L&#34;
                            if not needparen: break
                        elif tokens[j].value == &#39;(&#39;:
                            needparen = True
                        elif tokens[j].value == &#39;)&#39;:
                            break
                        else:
                            self.on_error(tokens[i].source,tokens[i].lineno,&#34;Malformed defined()&#34;)
                        j += 1
                    if result.startswith(&#39;defined&#39;):
                        tokens[i].type = self.t_ID
                        tokens[i].value = result
                    else:
                        tokens[i].type = self.t_INTEGER
                        tokens[i].value = self.t_INTEGER_TYPE(result)
                    del tokens[i+1:j+1]
                i += 1
            return tokens
        # Replace any defined(macro) before macro expansion
        tokens = replace_defined(tokens)
        tokens = self.expand_macros(tokens)
        # Replace any defined(macro) after macro expansion
        tokens = replace_defined(tokens)
        if not tokens:
            return (0, None)
        for i,t in enumerate(tokens):
            if t.type == self.t_ID:
                repl = self.on_unknown_macro_in_expr(copy.copy(t))
                if repl is None:
                    # Add this identifier to a dictionary of variables
                    evalvars[t.value] = 0
                else:
                    tokens[i] = t = repl
            if t.type == self.t_INTEGER:
                tokens[i] = copy.copy(t)
                # Strip off any trailing suffixes
                tokens[i].value = str(tokens[i].value)
                while tokens[i].value[-1] not in &#34;0123456789abcdefABCDEF&#34;:
                    tokens[i].value = tokens[i].value[:-1]
                if sys.version_info.major &gt;= 3:
                    if len(tokens[i].value) &gt; 1 and tokens[i].value[0] == &#39;0&#39; and tokens[i].value[1] &gt;= &#39;0&#39; and tokens[i].value[1] &lt;= &#39;7&#39;:
                        tokens[i].value = &#39;0o&#39; + tokens[i].value[1:]
            elif t.type == self.t_CHAR:
                tokens[i] = copy.copy(t)
                # Strip off any leading prefixes
                tokens[i].value = str(tokens[i].value)
                while tokens[i].value[0] != &#39;\&#39;&#39;:
                    tokens[i].value = tokens[i].value[1:]
                # Strip off quotes
                strip_value = tokens[i].value.strip(&#39;\&#39;&#39;)
                # Unescape character
                unescape_value = codecs.getdecoder(&#34;unicode_escape&#34;)(strip_value)[0]
                tokens[i].value = ord(unescape_value)
            elif t.type == self.t_COLON:
                # Find the expression before the colon
                cs = ce = i - 1
                while cs &gt; 0 and tokens[cs].type in self.t_WS:
                    cs -= 1
                if cs &gt; 0 and tokens[cs].value == &#39;)&#39;:
                    cs -= 1
                    brackets = 1
                    while cs &gt; 0:
                        if tokens[cs].value == &#39;)&#39;:
                            brackets += 1
                        elif tokens[cs].value == &#39;(&#39;:
                            brackets -= 1
                            if brackets == 0:
                                break
                        cs -= 1
                while cs &gt; 0 and tokens[cs].type != self.t_TERNARY:
                    cs -= 1
                ternary = cs
                cs += 1
                # Find the expression before the ternary
                es = ee = ternary - 1
                while es &gt; 0 and tokens[es].type in self.t_WS:
                    es -= 1
                if es &gt; 0 and tokens[es].value == &#39;)&#39;:
                    es -= 1
                    brackets = 1
                    while es &gt; 0:
                        if tokens[es].value == &#39;)&#39;:
                            brackets += 1
                        elif tokens[es].value == &#39;(&#39;:
                            brackets -= 1
                            if brackets == 0:
                                break
                        es -= 1
                else:
                    while es &gt; 0 and tokens[es].type not in self.t_WS:
                        es -= 1
                    if tokens[es].value == &#39;(&#39;:
                        es += 1
                # Swap the pre-ternary and post-ternary expressions
                tokens[ternary].value = &#39; if &#39;
                tokens[i].value = &#39; else &#39;
                # Note this is identical length
                tokens = tokens[:es] + tokens[cs:ce+1] + tokens[ternary:ternary+1] + tokens[es:ee+1] + tokens[i:]
        
        expr = origexpr = &#34;&#34;.join([str(x.value) for x in tokens if x.type not in self.t_COMMENT])
        expr = expr.replace(&#34;&amp;&amp;&#34;,&#34; and &#34;)
        expr = expr.replace(&#34;||&#34;,&#34; or &#34;)
        expr = expr.replace(&#34;!=&#34;,&#34; &lt;&gt; &#34;)
        expr = expr.replace(&#34;!&#34;,&#34; not &#34;)
        expr = expr.replace(&#34; &lt;&gt; &#34;, &#34; != &#34;)
        try:
            result = int(eval(expr, evalfuncts, evalvars))
        except Exception:
            print(&#34;%s:%d&#34; % (tokens[0].source,tokens[0].lineno), &#34;warning: couldn&#39;t evaluate expression due to&#34;, traceback.format_exc()
            + &#34;\nConverted expression was&#34;, expr, &#34;with evalvars =&#34;, repr(evalvars))
            result = 0
        return (result, tokens) if evalvars else (result, None)

    # ----------------------------------------------------------------------
    # parsegen()
    #
    # Parse an input string
    # ----------------------------------------------------------------------
    def parsegen(self,input,source=None,abssource=None):
        &#34;&#34;&#34;Parse an input string&#34;&#34;&#34;
        rewritten_source = source
        if abssource:
            rewritten_source = abssource
            for rewrite in self.rewrite_paths:
                temp = re.sub(rewrite[0], rewrite[1], rewritten_source)
                if temp != abssource:
                    rewritten_source = temp
                    if os.sep != &#39;/&#39;:
                        rewritten_source = rewritten_source.replace(os.sep, &#39;/&#39;)
                    break

        # Replace trigraph sequences
        t = trigraph(input)
        lines = self.group_lines(t, rewritten_source)

        if not source:
            source = &#34;&#34;
        if not rewritten_source:
            rewritten_source = &#34;&#34;
            
        my_include_times_idx = len(self.include_times)
        self.include_times.append(FileInclusionTime(self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None, source, abssource, self.include_depth))
        self.include_depth += 1
        my_include_time_begin = clock()
        if self.expand_filemacro:
            self.define(&#34;__FILE__ \&#34;%s\&#34;&#34; % rewritten_source)

        self.source = abssource
        chunk = []
        enable = True
        iftrigger = False
        ifpassthru = False
        class ifstackentry(object):
            def __init__(self,enable,iftrigger,ifpassthru,startlinetoks):
                self.enable = enable
                self.iftrigger = iftrigger
                self.ifpassthru = ifpassthru
                self.rewritten = False
                self.startlinetoks = startlinetoks
        ifstack = []
        # True until any non-whitespace output or anything with effects happens.
        at_front_of_file = True
        # True if auto pragma once still a possibility for this #include
        auto_pragma_once_possible = self.auto_pragma_once_enabled
        # =(MACRO, 0) means #ifndef MACRO or #if !defined(MACRO) seen, =(MACRO,1) means #define MACRO seen
        include_guard = None
        self.on_potential_include_guard(None)

        for x in lines:
            all_whitespace = True
            skip_auto_pragma_once_possible_check = False
            # Handle comments
            for i,tok in enumerate(x):
                if tok.type in self.t_COMMENT:
                    if not self.on_comment(tok):
                        if tok.type == self.t_COMMENT1:
                            tok.value = &#39; &#39;
                        elif tok.type == self.t_COMMENT2:
                            tok.value = &#39;\n&#39;
                        tok.type = &#39;CPP_WS&#39;
            # Skip over whitespace
            for i,tok in enumerate(x):
                if tok.type not in self.t_WS and tok.type not in self.t_COMMENT:
                    all_whitespace = False
                    break
            output_and_expand_line = True
            output_unexpanded_line = False
            if tok.value == &#39;#&#39;:
                precedingtoks = [ tok ]
                output_and_expand_line = False
                try:
                    # Preprocessor directive      
                    i += 1
                    while i &lt; len(x) and x[i].type in self.t_WS:
                        precedingtoks.append(x[i])
                        i += 1                    
                    dirtokens = self.tokenstrip(x[i:])
                    if dirtokens:
                        name = dirtokens[0].value
                        args = self.tokenstrip(dirtokens[1:])
                    
                        if self.debugout is not None:
                            print(&#34;%d:%d:%d %s:%d #%s %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, dirtokens[0].value, &#34;&#34;.join([tok.value for tok in args])), file = self.debugout)
                            #print(ifstack)

                        handling = self.on_directive_handle(dirtokens[0],args,ifpassthru,precedingtoks)
                        assert handling == True or handling == None
                    else:
                        name = &#34;&#34;
                        args = []
                        raise OutputDirective(Action.IgnoreAndRemove)
                        
                    if name == &#39;define&#39;:
                        at_front_of_file = False
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            if include_guard and include_guard[1] == 0:
                                if include_guard[0] == args[0].value and len(args) == 1:
                                    include_guard = (args[0].value, 1)
                                    # If ifpassthru is only turned on due to this include guard, turn it off
                                    if ifpassthru and not ifstack[-1].ifpassthru:
                                        ifpassthru = False
                            self.define(args)
                            if self.debugout is not None:
                                print(&#34;%d:%d:%d %s:%d      %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, repr(self.macros[args[0].value])), file = self.debugout)
                            if handling is None:
                                for tok in x:
                                    yield tok
                    elif name == &#39;include&#39;:
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            oldfile = self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None
                            for tok in self.include(args):
                                yield tok
                            if oldfile is not None:
                                self.macros[&#39;__FILE__&#39;] = oldfile
                            self.source = abssource
                    elif name == &#39;undef&#39;:
                        at_front_of_file = False
                        if enable:
                            for tok in self.expand_macros(chunk):
                                yield tok
                            chunk = []
                            self.undef(args)
                            if handling is None:
                                for tok in x:
                                    yield tok
                    elif name == &#39;ifdef&#39;:
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            ifpassthru = False
                            if not args[0].value in self.macros:
                                res = self.on_unknown_macro_in_defined_expr(args[0])
                                if res is None:
                                    ifpassthru = True
                                    ifstack[-1].rewritten = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                elif res is True:
                                    iftrigger = True
                                else:
                                    enable = False
                                    iftrigger = False
                            else:
                                iftrigger = True
                    elif name == &#39;ifndef&#39;:
                        if not ifstack and at_front_of_file:
                            self.on_potential_include_guard(args[0].value)
                            include_guard = (args[0].value, 0)
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            ifpassthru = False
                            if args[0].value in self.macros:
                                enable = False
                                iftrigger = False
                            else:
                                res = self.on_unknown_macro_in_defined_expr(args[0])
                                if res is None:
                                    ifpassthru = True
                                    ifstack[-1].rewritten = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                elif res is True:
                                    enable = False
                                    iftrigger = False
                                else:
                                    iftrigger = True
                    elif name == &#39;if&#39;:
                        if not ifstack and at_front_of_file:
                            if args[0].value == &#39;!&#39; and args[1].value == &#39;defined&#39;:
                                n = 2
                                if args[n].value == &#39;(&#39;: n += 1
                                self.on_potential_include_guard(args[n].value)
                                include_guard = (args[n].value, 0)
                        at_front_of_file = False
                        ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                        if enable:
                            iftrigger = False
                            ifpassthru = False
                            result, rewritten = self.evalexpr(args)
                            if rewritten is not None:
                                x = x[:i+2] + rewritten + [x[-1]]
                                x[i+1] = copy.copy(x[i+1])
                                x[i+1].type = self.t_SPACE
                                x[i+1].value = &#39; &#39;
                                ifpassthru = True
                                ifstack[-1].rewritten = True
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                            if not result:
                                enable = False
                            else:
                                iftrigger = True
                    elif name == &#39;elif&#39;:
                        at_front_of_file = False
                        if ifstack:
                            if ifstack[-1].enable:     # We only pay attention if outer &#34;if&#34; allows this
                                if enable and not ifpassthru:         # If already true, we flip enable False
                                    enable = False
                                elif not iftrigger:   # If False, but not triggered yet, we&#39;ll check expression
                                    result, rewritten = self.evalexpr(args)
                                    if rewritten is not None:
                                        enable = True
                                        if not ifpassthru:
                                            # This is a passthru #elif after a False #if, so convert to an #if
                                            x[i].value = &#39;if&#39;
                                        x = x[:i+2] + rewritten + [x[-1]]
                                        x[i+1] = copy.copy(x[i+1])
                                        x[i+1].type = self.t_SPACE
                                        x[i+1].value = &#39; &#39;
                                        ifpassthru = True
                                        ifstack[-1].rewritten = True
                                        raise OutputDirective(Action.IgnoreAndPassThrough)
                                    if ifpassthru:
                                        # If this elif can only ever be true, simulate that
                                        if result:
                                            newtok = copy.copy(x[i+3])
                                            newtok.type = self.t_INTEGER
                                            newtok.value = self.t_INTEGER_TYPE(result)
                                            x = x[:i+2] + [newtok] + [x[-1]]
                                            raise OutputDirective(Action.IgnoreAndPassThrough)
                                        # Otherwise elide
                                        enable = False
                                    elif result:
                                        enable  = True
                                        iftrigger = True
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #elif&#34;)
                            
                    elif name == &#39;else&#39;:
                        at_front_of_file = False
                        if ifstack:
                            if ifstack[-1].enable:
                                if ifpassthru:
                                    enable = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                if enable:
                                    enable = False
                                elif not iftrigger:
                                    enable = True
                                    iftrigger = True
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #else&#34;)

                    elif name == &#39;endif&#39;:
                        at_front_of_file = False
                        if ifstack:
                            oldifstackentry = ifstack.pop()
                            enable = oldifstackentry.enable
                            iftrigger = oldifstackentry.iftrigger
                            ifpassthru = oldifstackentry.ifpassthru
                            if self.debugout is not None:
                                print(&#34;%d:%d:%d %s:%d      (%s:%d %s)&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno,
                                    oldifstackentry.startlinetoks[0].source, oldifstackentry.startlinetoks[0].lineno, &#34;&#34;.join([n.value for n in oldifstackentry.startlinetoks])), file = self.debugout)
                            skip_auto_pragma_once_possible_check = True
                            if oldifstackentry.rewritten:
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                        else:
                            self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #endif&#34;)
                    elif name == &#39;pragma&#39; and args[0].value == &#39;once&#39;:
                        if enable:
                            self.include_once[self.source] = None
                    elif enable:
                        # Unknown preprocessor directive
                        output_unexpanded_line = (self.on_directive_unknown(dirtokens[0], args, ifpassthru, precedingtoks) is None)

                except OutputDirective as e:
                    if e.action == Action.IgnoreAndPassThrough:
                        output_unexpanded_line = True
                    elif e.action == Action.IgnoreAndRemove:
                        pass
                    else:
                        assert False

            # If there is ever any non-whitespace output outside an include guard, auto pragma once is not possible
            if not skip_auto_pragma_once_possible_check and auto_pragma_once_possible and not ifstack and not all_whitespace:
                auto_pragma_once_possible = False
                if self.debugout is not None:
                    print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is not entirely wrapped in an include guard macro, disabling auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, x[0].source, x[0].lineno, self.source), file = self.debugout)
                
            if output_and_expand_line or output_unexpanded_line:
                if not all_whitespace:
                    at_front_of_file = False

                # Normal text
                if enable:
                    if output_and_expand_line:
                        chunk.extend(x)
                    elif output_unexpanded_line:
                        for tok in self.expand_macros(chunk):
                            yield tok
                        chunk = []
                        for tok in x:
                            yield tok
                else:
                    # Need to extend with the same number of blank lines
                    i = 0
                    while i &lt; len(x):
                        if x[i].type not in self.t_WS:
                            del x[i]
                        else:
                            i += 1
                    chunk.extend(x)

        for tok in self.expand_macros(chunk):
            yield tok
        chunk = []
        for i in ifstack:
            self.on_error(i.startlinetoks[0].source, i.startlinetoks[0].lineno, &#34;Unterminated &#34; + &#34;&#34;.join([n.value for n in i.startlinetoks]))
        if auto_pragma_once_possible and include_guard and include_guard[1] == 1:
            if self.debugout is not None:
                print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is entirely wrapped in an include guard macro called %s, auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, self.source, 0, self.source, include_guard[0]), file = self.debugout)
            self.include_once[self.source] = include_guard[0]
        elif self.auto_pragma_once_enabled and self.source not in self.include_once:
            if self.debugout is not None:
                print(&#34;%d:%d:%d %s:%d Did not auto apply #pragma once to this file due to auto_pragma_once_possible=%d, include_guard=%s&#34; % (enable, iftrigger, ifpassthru, self.source, 0, auto_pragma_once_possible, repr(include_guard)), file = self.debugout)
        my_include_time_end = clock()
        self.include_times[my_include_times_idx].elapsed = my_include_time_end - my_include_time_begin
        self.include_depth -= 1

    # ----------------------------------------------------------------------
    # include()
    #
    # Implementation of file-inclusion
    # ----------------------------------------------------------------------

    def include(self,tokens):
        &#34;&#34;&#34;Implementation of file-inclusion&#34;&#34;&#34;
        # Try to extract the filename and then process an include file
        if not tokens:
            return
        if tokens:
            if tokens[0].value != &#39;&lt;&#39; and tokens[0].type != self.t_STRING:
                tokens = self.tokenstrip(self.expand_macros(tokens))

            is_system_include = False
            if tokens[0].value == &#39;&lt;&#39;:
                is_system_include = True
                # Include &lt;...&gt;
                i = 1
                while i &lt; len(tokens):
                    if tokens[i].value == &#39;&gt;&#39;:
                        break
                    i += 1
                else:
                    self.on_error(tokens[0].source,tokens[0].lineno,&#34;Malformed #include &lt;...&gt;&#34;)
                    return
                filename = &#34;&#34;.join([x.value for x in tokens[1:i]])
                # Search only formally specified paths
                path = self.path
            elif tokens[0].type == self.t_STRING:
                filename = tokens[0].value[1:-1]
                # Search from each nested include file, as well as formally specified paths
                path = self.temp_path + self.path
            else:
                p = self.on_include_not_found(True,False,self.temp_path[0] if self.temp_path else &#39;&#39;,tokens[0].value)
                assert p is None
                return
        if not path:
            path = [&#39;&#39;]
        while True:
            #print path
            for p in path:
                iname = os.path.join(p,filename)
                fulliname = os.path.abspath(iname)
                if fulliname in self.include_once:
                    if self.debugout is not None:
                        print(&#34;x:x:x x:x #include \&#34;%s\&#34; skipped as already seen&#34; % (fulliname), file = self.debugout)
                    return
                try:
                    ih = self.on_file_open(is_system_include,fulliname)
                    data = ih.read()
                    ih.close()
                    dname = os.path.dirname(fulliname)
                    if dname:
                        self.temp_path.insert(0,dname)
                    for tok in self.parsegen(data,filename,fulliname):
                        yield tok
                    if dname:
                        del self.temp_path[0]
                    return
                except IOError:
                    pass
            else:
                p = self.on_include_not_found(False,is_system_include,self.temp_path[0] if self.temp_path else &#39;&#39;,filename)
                assert p is not None
                path.append(p)

    # ----------------------------------------------------------------------
    # define()
    #
    # Define a new macro
    # ----------------------------------------------------------------------

    def define(self,tokens):
        &#34;&#34;&#34;Define a new macro&#34;&#34;&#34;
        if isinstance(tokens,STRING_TYPES):
            tokens = self.tokenize(tokens)
        else:
            tokens = [copy.copy(tok) for tok in tokens]
        def add_macro(self, name, macro):
            macro.source = name.source
            macro.lineno = name.lineno
            self.macros[name.value] = macro

        linetok = tokens
        try:
            name = linetok[0]
            if len(linetok) &gt; 1:
                mtype = linetok[1]
            else:
                mtype = None
            if not mtype:
                m = Macro(name.value,[])
                add_macro(self, name, m)
            elif mtype.type in self.t_WS:
                # A normal macro
                m = Macro(name.value,self.tokenstrip(linetok[2:]))
                add_macro(self, name, m)
            elif mtype.value == &#39;(&#39;:
                # A macro with arguments
                tokcount, args, positions = self.collect_args(linetok[1:])
                variadic = False
                for a in args:
                    if variadic:
                        self.on_error(name.source,name.lineno,&#34;No more arguments may follow a variadic argument&#34;)
                        break
                    astr = &#34;&#34;.join([str(_i.value) for _i in a])
                    if astr == &#34;...&#34;:
                        variadic = True
                        a[0].type = self.t_ID
                        a[0].value = &#39;__VA_ARGS__&#39;
                        variadic = True
                        del a[1:]
                        continue
                    elif astr[-3:] == &#34;...&#34; and a[0].type == self.t_ID:
                        variadic = True
                        del a[1:]
                        # If, for some reason, &#34;.&#34; is part of the identifier, strip off the name for the purposes
                        # of macro expansion
                        if a[0].value[-3:] == &#39;...&#39;:
                            a[0].value = a[0].value[:-3]
                        continue
                    # Empty arguments are permitted
                    if len(a) == 0 and len(args) == 1:
                        continue
                    if len(a) &gt; 1 or a[0].type != self.t_ID:
                        self.on_error(a[0].source,a[0].lineno,&#34;Invalid macro argument&#34;)
                        break
                else:
                    mvalue = self.tokenstrip(linetok[1+tokcount:])
                    i = 0
                    while i &lt; len(mvalue):
                        if i+1 &lt; len(mvalue):
                            if mvalue[i].type in self.t_WS and mvalue[i+1].value == &#39;##&#39;:
                                del mvalue[i]
                                continue
                            elif mvalue[i].value == &#39;##&#39; and mvalue[i+1].type in self.t_WS:
                                del mvalue[i+1]
                        i += 1
                    m = Macro(name.value,mvalue,[x[0].value for x in args] if args != [[]] else [],variadic)
                    self.macro_prescan(m)
                    add_macro(self, name, m)
            else:
                self.on_error(name.source,name.lineno,&#34;Bad macro definition&#34;)
        #except LookupError:
        #    print(&#34;Bad macro definition&#34;)
        except:
            raise

    # ----------------------------------------------------------------------
    # undef()
    #
    # Undefine a macro
    # ----------------------------------------------------------------------

    def undef(self,tokens):
        &#34;&#34;&#34;Undefine a macro&#34;&#34;&#34;
        if isinstance(tokens,STRING_TYPES):
            tokens = self.tokenize(tokens)
        id = tokens[0].value
        try:
            del self.macros[id]
        except LookupError:
            pass

    # ----------------------------------------------------------------------
    # parse()
    #
    # Parse input text.
    # ----------------------------------------------------------------------
    def parse(self,input,source=None,ignore={}):
        &#34;&#34;&#34;Parse input text.&#34;&#34;&#34;
        if isinstance(input, FILE_TYPES):
            if source is None:
                source = input.name
            input = input.read()
        self.ignore = ignore
        self.parser = self.parsegen(input,source,os.path.abspath(source) if source else None)
        if source is not None:
            dname = os.path.dirname(source)
            self.temp_path.insert(0,dname)
        
    # ----------------------------------------------------------------------
    # token()
    #
    # Method to return individual tokens
    # ----------------------------------------------------------------------
    def token(self):
        &#34;&#34;&#34;Method to return individual tokens&#34;&#34;&#34;
        try:
            while True:
                tok = next(self.parser)
                if tok.type not in self.ignore:
                    return tok
        except StopIteration:
            self.parser = None
            return None
            
    def write(self, oh=sys.stdout):
        &#34;&#34;&#34;Calls token() repeatedly, expanding tokens to their text and writing to the file like stream oh&#34;&#34;&#34;
        lastlineno = 0
        lastsource = None
        done = False
        blanklines = 0
        while not done:
            emitlinedirective = False
            toks = []
            all_ws = True
            # Accumulate a line
            while not done:
                tok = self.token()
                if not tok:
                    done = True
                    break
                toks.append(tok)
                if tok.value and tok.value[0] == &#39;\n&#39;:
                    break
                if tok.type not in self.t_WS:
                    all_ws = False
            if not toks:
                break
            if all_ws:
                # Remove preceding whitespace so it becomes just a LF
                if len(toks) &gt; 1:
                    tok = toks[-1]
                    toks = [ tok ]
                blanklines += toks[0].value.count(&#39;\n&#39;)
                continue
            # The line in toks is not all whitespace
            emitlinedirective = (blanklines &gt; 6) and self.line_directive is not None
            if hasattr(toks[0], &#39;source&#39;):
                if lastsource is None:
                    if toks[0].source is not None:
                        emitlinedirective = True
                    lastsource = toks[0].source
                elif lastsource != toks[0].source:
                    emitlinedirective = True
                    lastsource = toks[0].source
            # Replace consecutive whitespace in output with a single space except at any indent
            first_ws = None
            for n in xrange(len(toks)-1, -1, -1):
                tok = toks[n]
                if first_ws is None:
                    if tok.type in self.t_SPACE or len(tok.value) == 0:
                        first_ws = n
                else:
                    if tok.type not in self.t_SPACE and len(tok.value) &gt; 0:
                        m = n + 1
                        while m != first_ws:
                            del toks[m]
                            first_ws -= 1
                        first_ws = None
                        if self.compress &gt; 0:
                            # Collapse a token of many whitespace into single
                            if toks[m].value and toks[m].value[0] == &#39; &#39;:
                                toks[m].value = &#39; &#39;
            if not self.compress &gt; 1 and not emitlinedirective:
                newlinesneeded = toks[0].lineno - lastlineno - 1
                if newlinesneeded &gt; 6 and self.line_directive is not None:
                    emitlinedirective = True
                else:
                    while newlinesneeded &gt; 0:
                        oh.write(&#39;\n&#39;)
                        newlinesneeded -= 1
            lastlineno = toks[0].lineno
            # Account for those newlines in a multiline comment
            if emitlinedirective and self.line_directive is not None:
                oh.write(self.line_directive + &#39; &#39; + str(lastlineno) + (&#39;&#39; if lastsource is None else (&#39; &#34;&#39; + lastsource + &#39;&#34;&#39; )) + &#39;\n&#39;)
            for tok in toks:
                if tok.type == self.t_COMMENT1:
                    lastlineno += tok.value.count(&#39;\n&#39;)
            blanklines = 0
            #print toks[0].lineno, 
            for tok in toks:
                #print tok.value,
                oh.write(tok.value)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pcpp.preprocessor.Preprocessor.add_path"><code class="name flex">
<span>def <span class="ident">add_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a search path to the preprocessor.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_path(self,path):
    &#34;&#34;&#34;Adds a search path to the preprocessor. &#34;&#34;&#34;
    self.path.append(path)
    # If the search path being added is relative, or has a common ancestor to the
    # current working directory, add a rewrite to relativise includes from this
    # search path
    relpath = None
    try:
        relpath = os.path.relpath(path)
    except: pass
    if relpath is not None:
        self.rewrite_paths += [(re.escape(os.path.abspath(path) + os.sep) + &#39;(.*)&#39;, os.path.join(relpath, &#39;\\1&#39;))]</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.collect_args"><code class="name flex">
<span>def <span class="ident">collect_args</span></span>(<span>self, tokenlist, ignore_errors=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Collects comma separated arguments from a list of tokens.
The arguments
must be enclosed in parenthesis.
Returns a tuple (tokencount,args,positions)
where tokencount is the number of tokens consumed, args is a list of arguments,
and positions is a list of integers containing the starting index of each
argument.
Each argument is represented by a list of tokens.</p>
<p>When collecting arguments, leading and trailing whitespace is removed
from each argument.
</p>
<p>This function properly handles nested parenthesis and commas&mdash;these do not
define new arguments.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def collect_args(self,tokenlist,ignore_errors=False):
    &#34;&#34;&#34;Collects comma separated arguments from a list of tokens.   The arguments
    must be enclosed in parenthesis.  Returns a tuple (tokencount,args,positions)
    where tokencount is the number of tokens consumed, args is a list of arguments,
    and positions is a list of integers containing the starting index of each
    argument.  Each argument is represented by a list of tokens.
    
    When collecting arguments, leading and trailing whitespace is removed
    from each argument.  
    
    This function properly handles nested parenthesis and commas---these do not
    define new arguments.&#34;&#34;&#34;
    args = []
    positions = []
    current_arg = []
    nesting = 1
    tokenlen = len(tokenlist)

    # Search for the opening &#39;(&#39;.
    i = 0
    while (i &lt; tokenlen) and (tokenlist[i].type in self.t_WS):
        i += 1

    if (i &lt; tokenlen) and (tokenlist[i].value == &#39;(&#39;):
        positions.append(i+1)
    else:
        if not ignore_errors:
            self.on_error(tokenlist[0].source,tokenlist[0].lineno,&#34;Missing &#39;(&#39; in macro arguments&#34;)
        return 0, [], []

    i += 1

    while i &lt; tokenlen:
        t = tokenlist[i]
        if t.value == &#39;(&#39;:
            current_arg.append(t)
            nesting += 1
        elif t.value == &#39;)&#39;:
            nesting -= 1
            if nesting == 0:
                args.append(self.tokenstrip(current_arg))
                positions.append(i)
                return i+1,args,positions
            current_arg.append(t)
        elif t.value == &#39;,&#39; and nesting == 1:
            args.append(self.tokenstrip(current_arg))
            positions.append(i+1)
            current_arg = []
        else:
            current_arg.append(t)
        i += 1

    # Missing end argument
    if not ignore_errors:
        self.on_error(tokenlist[-1].source,tokenlist[-1].lineno,&#34;Missing &#39;)&#39; in macro arguments&#34;)
    return 0, [],[]</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.define"><code class="name flex">
<span>def <span class="ident">define</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Define a new macro</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def define(self,tokens):
    &#34;&#34;&#34;Define a new macro&#34;&#34;&#34;
    if isinstance(tokens,STRING_TYPES):
        tokens = self.tokenize(tokens)
    else:
        tokens = [copy.copy(tok) for tok in tokens]
    def add_macro(self, name, macro):
        macro.source = name.source
        macro.lineno = name.lineno
        self.macros[name.value] = macro

    linetok = tokens
    try:
        name = linetok[0]
        if len(linetok) &gt; 1:
            mtype = linetok[1]
        else:
            mtype = None
        if not mtype:
            m = Macro(name.value,[])
            add_macro(self, name, m)
        elif mtype.type in self.t_WS:
            # A normal macro
            m = Macro(name.value,self.tokenstrip(linetok[2:]))
            add_macro(self, name, m)
        elif mtype.value == &#39;(&#39;:
            # A macro with arguments
            tokcount, args, positions = self.collect_args(linetok[1:])
            variadic = False
            for a in args:
                if variadic:
                    self.on_error(name.source,name.lineno,&#34;No more arguments may follow a variadic argument&#34;)
                    break
                astr = &#34;&#34;.join([str(_i.value) for _i in a])
                if astr == &#34;...&#34;:
                    variadic = True
                    a[0].type = self.t_ID
                    a[0].value = &#39;__VA_ARGS__&#39;
                    variadic = True
                    del a[1:]
                    continue
                elif astr[-3:] == &#34;...&#34; and a[0].type == self.t_ID:
                    variadic = True
                    del a[1:]
                    # If, for some reason, &#34;.&#34; is part of the identifier, strip off the name for the purposes
                    # of macro expansion
                    if a[0].value[-3:] == &#39;...&#39;:
                        a[0].value = a[0].value[:-3]
                    continue
                # Empty arguments are permitted
                if len(a) == 0 and len(args) == 1:
                    continue
                if len(a) &gt; 1 or a[0].type != self.t_ID:
                    self.on_error(a[0].source,a[0].lineno,&#34;Invalid macro argument&#34;)
                    break
            else:
                mvalue = self.tokenstrip(linetok[1+tokcount:])
                i = 0
                while i &lt; len(mvalue):
                    if i+1 &lt; len(mvalue):
                        if mvalue[i].type in self.t_WS and mvalue[i+1].value == &#39;##&#39;:
                            del mvalue[i]
                            continue
                        elif mvalue[i].value == &#39;##&#39; and mvalue[i+1].type in self.t_WS:
                            del mvalue[i+1]
                    i += 1
                m = Macro(name.value,mvalue,[x[0].value for x in args] if args != [[]] else [],variadic)
                self.macro_prescan(m)
                add_macro(self, name, m)
        else:
            self.on_error(name.source,name.lineno,&#34;Bad macro definition&#34;)
    #except LookupError:
    #    print(&#34;Bad macro definition&#34;)
    except:
        raise</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.evalexpr"><code class="name flex">
<span>def <span class="ident">evalexpr</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Evaluate an expression token sequence for the purposes of evaluating
integral expressions.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def evalexpr(self,tokens):
    &#34;&#34;&#34;Evaluate an expression token sequence for the purposes of evaluating
    integral expressions.&#34;&#34;&#34;
    if not tokens:
        self.on_error(&#39;unknown&#39;, 0, &#34;Empty expression&#34;)
        return (0, None)
    # tokens = tokenize(line)
    # Search for defined macros
    evalfuncts = {&#39;defined&#39; : lambda x: True}
    evalvars = {}
    def replace_defined(tokens):
        i = 0
        while i &lt; len(tokens):
            if tokens[i].type == self.t_ID and tokens[i].value == &#39;defined&#39;:
                j = i + 1
                needparen = False
                result = &#34;0L&#34;
                while j &lt; len(tokens):
                    if tokens[j].type in self.t_WS:
                        j += 1
                        continue
                    elif tokens[j].type == self.t_ID:
                        if tokens[j].value in self.macros:
                            result = &#34;1L&#34;
                        else:
                            repl = self.on_unknown_macro_in_defined_expr(tokens[j])
                            if repl is None:
                                # Add this identifier to a dictionary of variables
                                evalvars[tokens[j].value] = 0
                                result = &#39;defined(&#39;+tokens[j].value+&#39;)&#39;
                            else:
                                result = &#34;1L&#34; if repl else &#34;0L&#34;
                        if not needparen: break
                    elif tokens[j].value == &#39;(&#39;:
                        needparen = True
                    elif tokens[j].value == &#39;)&#39;:
                        break
                    else:
                        self.on_error(tokens[i].source,tokens[i].lineno,&#34;Malformed defined()&#34;)
                    j += 1
                if result.startswith(&#39;defined&#39;):
                    tokens[i].type = self.t_ID
                    tokens[i].value = result
                else:
                    tokens[i].type = self.t_INTEGER
                    tokens[i].value = self.t_INTEGER_TYPE(result)
                del tokens[i+1:j+1]
            i += 1
        return tokens
    # Replace any defined(macro) before macro expansion
    tokens = replace_defined(tokens)
    tokens = self.expand_macros(tokens)
    # Replace any defined(macro) after macro expansion
    tokens = replace_defined(tokens)
    if not tokens:
        return (0, None)
    for i,t in enumerate(tokens):
        if t.type == self.t_ID:
            repl = self.on_unknown_macro_in_expr(copy.copy(t))
            if repl is None:
                # Add this identifier to a dictionary of variables
                evalvars[t.value] = 0
            else:
                tokens[i] = t = repl
        if t.type == self.t_INTEGER:
            tokens[i] = copy.copy(t)
            # Strip off any trailing suffixes
            tokens[i].value = str(tokens[i].value)
            while tokens[i].value[-1] not in &#34;0123456789abcdefABCDEF&#34;:
                tokens[i].value = tokens[i].value[:-1]
            if sys.version_info.major &gt;= 3:
                if len(tokens[i].value) &gt; 1 and tokens[i].value[0] == &#39;0&#39; and tokens[i].value[1] &gt;= &#39;0&#39; and tokens[i].value[1] &lt;= &#39;7&#39;:
                    tokens[i].value = &#39;0o&#39; + tokens[i].value[1:]
        elif t.type == self.t_CHAR:
            tokens[i] = copy.copy(t)
            # Strip off any leading prefixes
            tokens[i].value = str(tokens[i].value)
            while tokens[i].value[0] != &#39;\&#39;&#39;:
                tokens[i].value = tokens[i].value[1:]
            # Strip off quotes
            strip_value = tokens[i].value.strip(&#39;\&#39;&#39;)
            # Unescape character
            unescape_value = codecs.getdecoder(&#34;unicode_escape&#34;)(strip_value)[0]
            tokens[i].value = ord(unescape_value)
        elif t.type == self.t_COLON:
            # Find the expression before the colon
            cs = ce = i - 1
            while cs &gt; 0 and tokens[cs].type in self.t_WS:
                cs -= 1
            if cs &gt; 0 and tokens[cs].value == &#39;)&#39;:
                cs -= 1
                brackets = 1
                while cs &gt; 0:
                    if tokens[cs].value == &#39;)&#39;:
                        brackets += 1
                    elif tokens[cs].value == &#39;(&#39;:
                        brackets -= 1
                        if brackets == 0:
                            break
                    cs -= 1
            while cs &gt; 0 and tokens[cs].type != self.t_TERNARY:
                cs -= 1
            ternary = cs
            cs += 1
            # Find the expression before the ternary
            es = ee = ternary - 1
            while es &gt; 0 and tokens[es].type in self.t_WS:
                es -= 1
            if es &gt; 0 and tokens[es].value == &#39;)&#39;:
                es -= 1
                brackets = 1
                while es &gt; 0:
                    if tokens[es].value == &#39;)&#39;:
                        brackets += 1
                    elif tokens[es].value == &#39;(&#39;:
                        brackets -= 1
                        if brackets == 0:
                            break
                    es -= 1
            else:
                while es &gt; 0 and tokens[es].type not in self.t_WS:
                    es -= 1
                if tokens[es].value == &#39;(&#39;:
                    es += 1
            # Swap the pre-ternary and post-ternary expressions
            tokens[ternary].value = &#39; if &#39;
            tokens[i].value = &#39; else &#39;
            # Note this is identical length
            tokens = tokens[:es] + tokens[cs:ce+1] + tokens[ternary:ternary+1] + tokens[es:ee+1] + tokens[i:]
    
    expr = origexpr = &#34;&#34;.join([str(x.value) for x in tokens if x.type not in self.t_COMMENT])
    expr = expr.replace(&#34;&amp;&amp;&#34;,&#34; and &#34;)
    expr = expr.replace(&#34;||&#34;,&#34; or &#34;)
    expr = expr.replace(&#34;!=&#34;,&#34; &lt;&gt; &#34;)
    expr = expr.replace(&#34;!&#34;,&#34; not &#34;)
    expr = expr.replace(&#34; &lt;&gt; &#34;, &#34; != &#34;)
    try:
        result = int(eval(expr, evalfuncts, evalvars))
    except Exception:
        print(&#34;%s:%d&#34; % (tokens[0].source,tokens[0].lineno), &#34;warning: couldn&#39;t evaluate expression due to&#34;, traceback.format_exc()
        + &#34;\nConverted expression was&#34;, expr, &#34;with evalvars =&#34;, repr(evalvars))
        result = 0
    return (result, tokens) if evalvars else (result, None)</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.expand_macros"><code class="name flex">
<span>def <span class="ident">expand_macros</span></span>(<span>self, tokens, expanding_from=[])</span>
</code></dt>
<dd>
<section class="desc"><p>Given a list of tokens, this function performs macro expansion.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def expand_macros(self,tokens,expanding_from=[]):
    &#34;&#34;&#34;Given a list of tokens, this function performs macro expansion.&#34;&#34;&#34;
    # Each token needs to track from which macros it has been expanded from to prevent recursion
    for tok in tokens:
        if not hasattr(tok, &#39;expanded_from&#39;):
            tok.expanded_from = []
    i = 0
    #print &#34;*** EXPAND MACROS in&#34;, &#34;&#34;.join([t.value for t in tokens]), &#34;expanding_from=&#34;, expanding_from
    #print tokens
    #print [(t.value, t.expanded_from) for t in tokens]
    while i &lt; len(tokens):
        t = tokens[i]
        if self.linemacrodepth == 0:
            self.linemacro = t.lineno
        self.linemacrodepth = self.linemacrodepth + 1
        if t.type == self.t_ID:
            if t.value in self.macros and t.value not in t.expanded_from and t.value not in expanding_from:
                # Yes, we found a macro match
                m = self.macros[t.value]
                if m.arglist is None:
                    # A simple macro
                    rep = [copy.copy(_x) for _x in m.value]
                    ex = self.expand_macros(rep, expanding_from + [t.value])
                    #print &#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:i+1]
                    for e in ex:
                        e.source = t.source
                        e.lineno = t.lineno
                        if not hasattr(e, &#39;expanded_from&#39;):
                            e.expanded_from = []
                        e.expanded_from.append(t.value)
                    tokens[i:i+1] = ex
                else:
                    # A macro with arguments
                    j = i + 1
                    while j &lt; len(tokens) and (tokens[j].type in self.t_WS or tokens[j].type in self.t_COMMENT):
                        j += 1
                    # A function like macro without an invocation list is to be ignored
                    if j == len(tokens) or tokens[j].value != &#39;(&#39;:
                        i = j
                    else:
                        tokcount,args,positions = self.collect_args(tokens[j:], True)
                        if tokcount == 0:
                            # Unclosed parameter list, just bail out
                            break
                        if (not m.variadic
                            # A no arg or single arg consuming macro is permitted to be expanded with nothing
                            and (args != [[]] or len(m.arglist) &gt; 1)
                            and len(args) !=  len(m.arglist)):
                            self.on_error(t.source,t.lineno,&#34;Macro %s requires %d arguments but was passed %d&#34; % (t.value,len(m.arglist),len(args)))
                            i = j + tokcount
                        elif m.variadic and len(args) &lt; len(m.arglist)-1:
                            if len(m.arglist) &gt; 2:
                                self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d arguments&#34; % (t.value, len(m.arglist)-1))
                            else:
                                self.on_error(t.source,t.lineno,&#34;Macro %s must have at least %d argument&#34; % (t.value, len(m.arglist)-1))
                            i = j + tokcount
                        else:
                            if m.variadic:
                                if len(args) == len(m.arglist)-1:
                                    args.append([])
                                else:
                                    args[len(m.arglist)-1] = tokens[j+positions[len(m.arglist)-1]:j+tokcount-1]
                                    del args[len(m.arglist):]
                            else:
                                # If we called a single arg macro with empty, fake extend args
                                while len(args) &lt; len(m.arglist):
                                    args.append([])
                                    
                            # Get macro replacement text
                            rep = self.macro_expand_args(m,args)
                            ex = self.expand_macros(rep, expanding_from + [t.value])
                            for e in ex:
                                e.source = t.source
                                e.lineno = t.lineno
                                if not hasattr(e, &#39;expanded_from&#39;):
                                    e.expanded_from = []
                                e.expanded_from.append(t.value)
                            # A non-conforming extension implemented by the GCC and clang preprocessors
                            # is that an expansion of a macro with arguments where the following token is
                            # an identifier inserts a space between the expansion and the identifier. This
                            # differs from Boost.Wave incidentally (see https://github.com/ned14/pcpp/issues/29)
                            if len(tokens) &gt; j+tokcount and tokens[j+tokcount].type in self.t_ID:
                                #print(&#34;*** token after expansion is&#34;, tokens[j+tokcount])
                                newtok = copy.copy(tokens[j+tokcount])
                                newtok.type = self.t_SPACE
                                newtok.value = &#39; &#39;
                                ex.append(newtok)
                            #print(&#34;\nExpanding macro&#34;, m, &#34;\ninto&#34;, ex, &#34;\nreplacing&#34;, tokens[i:j+tokcount])
                            tokens[i:j+tokcount] = ex
                self.linemacrodepth = self.linemacrodepth - 1
                if self.linemacrodepth == 0:
                    self.linemacro = 0
                continue
            elif self.expand_linemacro and t.value == &#39;__LINE__&#39;:
                t.type = self.t_INTEGER
                t.value = self.t_INTEGER_TYPE(self.linemacro)
            elif self.expand_countermacro and t.value == &#39;__COUNTER__&#39;:
                t.type = self.t_INTEGER
                t.value = self.t_INTEGER_TYPE(self.countermacro)
                self.countermacro += 1
            
        i += 1
        self.linemacrodepth = self.linemacrodepth - 1
        if self.linemacrodepth == 0:
            self.linemacro = 0
    return tokens</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.group_lines"><code class="name flex">
<span>def <span class="ident">group_lines</span></span>(<span>self, input, abssource)</span>
</code></dt>
<dd>
<section class="desc"><p>Given an input string, this function splits it into lines.
Trailing whitespace
is removed. This function forms the lowest level of the preprocessor&mdash;grouping
text into a line-by-line format.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def group_lines(self,input,abssource):
    r&#34;&#34;&#34;Given an input string, this function splits it into lines.  Trailing whitespace
    is removed. This function forms the lowest level of the preprocessor---grouping
    text into a line-by-line format.
    &#34;&#34;&#34;
    lex = self.lexer.clone()
    lines = [x.rstrip() for x in input.splitlines()]

    input = &#34;\n&#34;.join(lines)
    lex.input(input)
    lex.lineno = 1

    current_line = []
    while True:
        tok = lex.token()
        if not tok:
            break
        tok.source = abssource
        current_line.append(tok)
        if tok.type in self.t_WS and tok.value == &#39;\n&#39;:
            yield current_line
            current_line = []

    if current_line:
        nltok = copy.copy(current_line[-1])
        nltok.type = self.t_NEWLINE
        nltok.value = &#39;\n&#39;
        current_line.append(nltok)
        yield current_line</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.include"><code class="name flex">
<span>def <span class="ident">include</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Implementation of file-inclusion</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def include(self,tokens):
    &#34;&#34;&#34;Implementation of file-inclusion&#34;&#34;&#34;
    # Try to extract the filename and then process an include file
    if not tokens:
        return
    if tokens:
        if tokens[0].value != &#39;&lt;&#39; and tokens[0].type != self.t_STRING:
            tokens = self.tokenstrip(self.expand_macros(tokens))

        is_system_include = False
        if tokens[0].value == &#39;&lt;&#39;:
            is_system_include = True
            # Include &lt;...&gt;
            i = 1
            while i &lt; len(tokens):
                if tokens[i].value == &#39;&gt;&#39;:
                    break
                i += 1
            else:
                self.on_error(tokens[0].source,tokens[0].lineno,&#34;Malformed #include &lt;...&gt;&#34;)
                return
            filename = &#34;&#34;.join([x.value for x in tokens[1:i]])
            # Search only formally specified paths
            path = self.path
        elif tokens[0].type == self.t_STRING:
            filename = tokens[0].value[1:-1]
            # Search from each nested include file, as well as formally specified paths
            path = self.temp_path + self.path
        else:
            p = self.on_include_not_found(True,False,self.temp_path[0] if self.temp_path else &#39;&#39;,tokens[0].value)
            assert p is None
            return
    if not path:
        path = [&#39;&#39;]
    while True:
        #print path
        for p in path:
            iname = os.path.join(p,filename)
            fulliname = os.path.abspath(iname)
            if fulliname in self.include_once:
                if self.debugout is not None:
                    print(&#34;x:x:x x:x #include \&#34;%s\&#34; skipped as already seen&#34; % (fulliname), file = self.debugout)
                return
            try:
                ih = self.on_file_open(is_system_include,fulliname)
                data = ih.read()
                ih.close()
                dname = os.path.dirname(fulliname)
                if dname:
                    self.temp_path.insert(0,dname)
                for tok in self.parsegen(data,filename,fulliname):
                    yield tok
                if dname:
                    del self.temp_path[0]
                return
            except IOError:
                pass
        else:
            p = self.on_include_not_found(False,is_system_include,self.temp_path[0] if self.temp_path else &#39;&#39;,filename)
            assert p is not None
            path.append(p)</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.macro_expand_args"><code class="name flex">
<span>def <span class="ident">macro_expand_args</span></span>(<span>self, macro, args)</span>
</code></dt>
<dd>
<section class="desc"><p>Given a Macro and list of arguments (each a token list), this method
returns an expanded version of a macro.
The return value is a token sequence
representing the replacement macro tokens</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def macro_expand_args(self,macro,args):
    &#34;&#34;&#34;Given a Macro and list of arguments (each a token list), this method
    returns an expanded version of a macro.  The return value is a token sequence
    representing the replacement macro tokens&#34;&#34;&#34;
    # Make a copy of the macro token sequence
    rep = [copy.copy(_x) for _x in macro.value]

    # Make string expansion patches.  These do not alter the length of the replacement sequence
    str_expansion = {}
    for argnum, i in macro.str_patch:
        if argnum not in str_expansion:
            # Strip all non-space whitespace before stringization
            tokens = copy.copy(args[argnum])
            for j in xrange(len(tokens)):
                if tokens[j].type in self.t_WS and tokens[j].type != self.t_LINECONT:
                    tokens[j].value = &#39; &#39;
            # Collapse all multiple whitespace too
            j = 0
            while j &lt; len(tokens) - 1:
                if tokens[j].type in self.t_WS and tokens[j+1].type in self.t_WS:
                    del tokens[j+1]
                else:
                    j += 1
            str = &#34;&#34;.join([x.value for x in tokens])
            str = str.replace(&#34;\\&#34;,&#34;\\\\&#34;).replace(&#39;&#34;&#39;, &#39;\\&#34;&#39;)
            str_expansion[argnum] = &#39;&#34;&#39; + str + &#39;&#34;&#39;
        rep[i] = copy.copy(rep[i])
        rep[i].value = str_expansion[argnum]

    # Make the variadic macro comma patch.  If the variadic macro argument is empty, we get rid
    comma_patch = False
    if macro.variadic and not args[-1]:
        for i in macro.var_comma_patch:
            rep[i] = None
            comma_patch = True

    # Make all other patches.   The order of these matters.  It is assumed that the patch list
    # has been sorted in reverse order of patch location since replacements will cause the
    # size of the replacement sequence to expand from the patch point.
    
    expanded = { }
    #print(&#34;***&#34;, macro)
    #print(macro.patch)
    for ptype, argnum, i in macro.patch:
        # Concatenation.   Argument is left unexpanded
        if ptype == &#39;t&#39;:
            rep[i:i+1] = args[argnum]
        # Normal expansion.  Argument is macro expanded first
        elif ptype == &#39;e&#39;:
            if argnum not in expanded:
                expanded[argnum] = self.expand_macros(args[argnum])
            rep[i:i+1] = expanded[argnum]

    # Get rid of removed comma if necessary
    if comma_patch:
        rep = [_i for _i in rep if _i]
        
    # Do a token concatenation pass, stitching any tokens separated by ## into a single token
    while len(rep) and rep[0].type == self.t_DPOUND:
        del rep[0]
    while len(rep) and rep[-1].type == self.t_DPOUND:
        del rep[-1]
    i = 1
    stitched = False
    while i &lt; len(rep) - 1:
        if rep[i].type == self.t_DPOUND:
            j = i + 1
            while rep[j].type == self.t_DPOUND:
                j += 1
            rep[i-1] = copy.copy(rep[i-1])
            rep[i-1].type = None
            rep[i-1].value += rep[j].value
            while j &gt;= i:
                del rep[i]
                j -= 1
            stitched = True
        else:
            i += 1
    if stitched:
        # Stitched tokens will have unknown type, so figure those out now
        i = 0
        lex = self.lexer.clone()
        while i &lt; len(rep):
            if rep[i].type is None:
                lex.input(rep[i].value)
                toks = []
                while True:
                    tok = lex.token()
                    if not tok:
                        break
                    toks.append(tok)
                if len(toks) != 1:
                    # Split it once again
                    while len(toks) &gt; 1:
                        rep.insert(i+1, copy.copy(rep[i]))
                        rep[i+1].value = toks[-1].value
                        rep[i+1].type = toks[-1].type
                        toks.pop()
                    rep[i].value = toks[0].value
                    rep[i].type = toks[0].type
                else:
                    rep[i].type = toks[0].type
            i += 1

    #print rep
    return rep</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.macro_prescan"><code class="name flex">
<span>def <span class="ident">macro_prescan</span></span>(<span>self, macro)</span>
</code></dt>
<dd>
<section class="desc"><p>Examine the macro value (token sequence) and identify patch points
This is used to speed up macro expansion later on&mdash;we'll know
right away where to apply patches to the value to form the expansion</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def macro_prescan(self,macro):
    &#34;&#34;&#34;Examine the macro value (token sequence) and identify patch points
    This is used to speed up macro expansion later on---we&#39;ll know
    right away where to apply patches to the value to form the expansion&#34;&#34;&#34;
    macro.patch     = []             # Standard macro arguments 
    macro.str_patch = []             # String conversion expansion
    macro.var_comma_patch = []       # Variadic macro comma patch
    i = 0
    #print(&#34;BEFORE&#34;, macro.value)
    while i &lt; len(macro.value):
        if macro.value[i].type == self.t_ID and macro.value[i].value in macro.arglist:
            argnum = macro.arglist.index(macro.value[i].value)
            # Conversion of argument to a string
            j = i - 1
            while j &gt;= 0 and macro.value[j].type in self.t_WS:
                j -= 1
            if j &gt;= 0 and macro.value[j].value == &#39;#&#39;:
                macro.value[i] = copy.copy(macro.value[i])
                macro.value[i].type = self.t_STRING
                while i &gt; j:
                    del macro.value[j]
                    i -= 1
                macro.str_patch.append((argnum,i))
                continue
            # Concatenation
            elif (i &gt; 0 and macro.value[i-1].value == &#39;##&#39;):
                macro.patch.append((&#39;t&#39;,argnum,i))
                i += 1
                continue
            elif ((i+1) &lt; len(macro.value) and macro.value[i+1].value == &#39;##&#39;):
                macro.patch.append((&#39;t&#39;,argnum,i))
                i += 1
                continue
            # Standard expansion
            else:
                macro.patch.append((&#39;e&#39;,argnum,i))
        elif macro.value[i].value == &#39;##&#39;:
            if macro.variadic and (i &gt; 0) and (macro.value[i-1].value == &#39;,&#39;) and \
                    ((i+1) &lt; len(macro.value)) and (macro.value[i+1].type == self.t_ID) and \
                    (macro.value[i+1].value == macro.vararg):
                macro.var_comma_patch.append(i-1)
        i += 1
    macro.patch.sort(key=lambda x: x[2],reverse=True)</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, input, source=None, ignore={})</span>
</code></dt>
<dd>
<section class="desc"><p>Parse input text.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parse(self,input,source=None,ignore={}):
    &#34;&#34;&#34;Parse input text.&#34;&#34;&#34;
    if isinstance(input, FILE_TYPES):
        if source is None:
            source = input.name
        input = input.read()
    self.ignore = ignore
    self.parser = self.parsegen(input,source,os.path.abspath(source) if source else None)
    if source is not None:
        dname = os.path.dirname(source)
        self.temp_path.insert(0,dname)</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.parsegen"><code class="name flex">
<span>def <span class="ident">parsegen</span></span>(<span>self, input, source=None, abssource=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Parse an input string</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parsegen(self,input,source=None,abssource=None):
    &#34;&#34;&#34;Parse an input string&#34;&#34;&#34;
    rewritten_source = source
    if abssource:
        rewritten_source = abssource
        for rewrite in self.rewrite_paths:
            temp = re.sub(rewrite[0], rewrite[1], rewritten_source)
            if temp != abssource:
                rewritten_source = temp
                if os.sep != &#39;/&#39;:
                    rewritten_source = rewritten_source.replace(os.sep, &#39;/&#39;)
                break

    # Replace trigraph sequences
    t = trigraph(input)
    lines = self.group_lines(t, rewritten_source)

    if not source:
        source = &#34;&#34;
    if not rewritten_source:
        rewritten_source = &#34;&#34;
        
    my_include_times_idx = len(self.include_times)
    self.include_times.append(FileInclusionTime(self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None, source, abssource, self.include_depth))
    self.include_depth += 1
    my_include_time_begin = clock()
    if self.expand_filemacro:
        self.define(&#34;__FILE__ \&#34;%s\&#34;&#34; % rewritten_source)

    self.source = abssource
    chunk = []
    enable = True
    iftrigger = False
    ifpassthru = False
    class ifstackentry(object):
        def __init__(self,enable,iftrigger,ifpassthru,startlinetoks):
            self.enable = enable
            self.iftrigger = iftrigger
            self.ifpassthru = ifpassthru
            self.rewritten = False
            self.startlinetoks = startlinetoks
    ifstack = []
    # True until any non-whitespace output or anything with effects happens.
    at_front_of_file = True
    # True if auto pragma once still a possibility for this #include
    auto_pragma_once_possible = self.auto_pragma_once_enabled
    # =(MACRO, 0) means #ifndef MACRO or #if !defined(MACRO) seen, =(MACRO,1) means #define MACRO seen
    include_guard = None
    self.on_potential_include_guard(None)

    for x in lines:
        all_whitespace = True
        skip_auto_pragma_once_possible_check = False
        # Handle comments
        for i,tok in enumerate(x):
            if tok.type in self.t_COMMENT:
                if not self.on_comment(tok):
                    if tok.type == self.t_COMMENT1:
                        tok.value = &#39; &#39;
                    elif tok.type == self.t_COMMENT2:
                        tok.value = &#39;\n&#39;
                    tok.type = &#39;CPP_WS&#39;
        # Skip over whitespace
        for i,tok in enumerate(x):
            if tok.type not in self.t_WS and tok.type not in self.t_COMMENT:
                all_whitespace = False
                break
        output_and_expand_line = True
        output_unexpanded_line = False
        if tok.value == &#39;#&#39;:
            precedingtoks = [ tok ]
            output_and_expand_line = False
            try:
                # Preprocessor directive      
                i += 1
                while i &lt; len(x) and x[i].type in self.t_WS:
                    precedingtoks.append(x[i])
                    i += 1                    
                dirtokens = self.tokenstrip(x[i:])
                if dirtokens:
                    name = dirtokens[0].value
                    args = self.tokenstrip(dirtokens[1:])
                
                    if self.debugout is not None:
                        print(&#34;%d:%d:%d %s:%d #%s %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, dirtokens[0].value, &#34;&#34;.join([tok.value for tok in args])), file = self.debugout)
                        #print(ifstack)

                    handling = self.on_directive_handle(dirtokens[0],args,ifpassthru,precedingtoks)
                    assert handling == True or handling == None
                else:
                    name = &#34;&#34;
                    args = []
                    raise OutputDirective(Action.IgnoreAndRemove)
                    
                if name == &#39;define&#39;:
                    at_front_of_file = False
                    if enable:
                        for tok in self.expand_macros(chunk):
                            yield tok
                        chunk = []
                        if include_guard and include_guard[1] == 0:
                            if include_guard[0] == args[0].value and len(args) == 1:
                                include_guard = (args[0].value, 1)
                                # If ifpassthru is only turned on due to this include guard, turn it off
                                if ifpassthru and not ifstack[-1].ifpassthru:
                                    ifpassthru = False
                        self.define(args)
                        if self.debugout is not None:
                            print(&#34;%d:%d:%d %s:%d      %s&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno, repr(self.macros[args[0].value])), file = self.debugout)
                        if handling is None:
                            for tok in x:
                                yield tok
                elif name == &#39;include&#39;:
                    if enable:
                        for tok in self.expand_macros(chunk):
                            yield tok
                        chunk = []
                        oldfile = self.macros[&#39;__FILE__&#39;] if &#39;__FILE__&#39; in self.macros else None
                        for tok in self.include(args):
                            yield tok
                        if oldfile is not None:
                            self.macros[&#39;__FILE__&#39;] = oldfile
                        self.source = abssource
                elif name == &#39;undef&#39;:
                    at_front_of_file = False
                    if enable:
                        for tok in self.expand_macros(chunk):
                            yield tok
                        chunk = []
                        self.undef(args)
                        if handling is None:
                            for tok in x:
                                yield tok
                elif name == &#39;ifdef&#39;:
                    at_front_of_file = False
                    ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                    if enable:
                        ifpassthru = False
                        if not args[0].value in self.macros:
                            res = self.on_unknown_macro_in_defined_expr(args[0])
                            if res is None:
                                ifpassthru = True
                                ifstack[-1].rewritten = True
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                            elif res is True:
                                iftrigger = True
                            else:
                                enable = False
                                iftrigger = False
                        else:
                            iftrigger = True
                elif name == &#39;ifndef&#39;:
                    if not ifstack and at_front_of_file:
                        self.on_potential_include_guard(args[0].value)
                        include_guard = (args[0].value, 0)
                    at_front_of_file = False
                    ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                    if enable:
                        ifpassthru = False
                        if args[0].value in self.macros:
                            enable = False
                            iftrigger = False
                        else:
                            res = self.on_unknown_macro_in_defined_expr(args[0])
                            if res is None:
                                ifpassthru = True
                                ifstack[-1].rewritten = True
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                            elif res is True:
                                enable = False
                                iftrigger = False
                            else:
                                iftrigger = True
                elif name == &#39;if&#39;:
                    if not ifstack and at_front_of_file:
                        if args[0].value == &#39;!&#39; and args[1].value == &#39;defined&#39;:
                            n = 2
                            if args[n].value == &#39;(&#39;: n += 1
                            self.on_potential_include_guard(args[n].value)
                            include_guard = (args[n].value, 0)
                    at_front_of_file = False
                    ifstack.append(ifstackentry(enable,iftrigger,ifpassthru,x))
                    if enable:
                        iftrigger = False
                        ifpassthru = False
                        result, rewritten = self.evalexpr(args)
                        if rewritten is not None:
                            x = x[:i+2] + rewritten + [x[-1]]
                            x[i+1] = copy.copy(x[i+1])
                            x[i+1].type = self.t_SPACE
                            x[i+1].value = &#39; &#39;
                            ifpassthru = True
                            ifstack[-1].rewritten = True
                            raise OutputDirective(Action.IgnoreAndPassThrough)
                        if not result:
                            enable = False
                        else:
                            iftrigger = True
                elif name == &#39;elif&#39;:
                    at_front_of_file = False
                    if ifstack:
                        if ifstack[-1].enable:     # We only pay attention if outer &#34;if&#34; allows this
                            if enable and not ifpassthru:         # If already true, we flip enable False
                                enable = False
                            elif not iftrigger:   # If False, but not triggered yet, we&#39;ll check expression
                                result, rewritten = self.evalexpr(args)
                                if rewritten is not None:
                                    enable = True
                                    if not ifpassthru:
                                        # This is a passthru #elif after a False #if, so convert to an #if
                                        x[i].value = &#39;if&#39;
                                    x = x[:i+2] + rewritten + [x[-1]]
                                    x[i+1] = copy.copy(x[i+1])
                                    x[i+1].type = self.t_SPACE
                                    x[i+1].value = &#39; &#39;
                                    ifpassthru = True
                                    ifstack[-1].rewritten = True
                                    raise OutputDirective(Action.IgnoreAndPassThrough)
                                if ifpassthru:
                                    # If this elif can only ever be true, simulate that
                                    if result:
                                        newtok = copy.copy(x[i+3])
                                        newtok.type = self.t_INTEGER
                                        newtok.value = self.t_INTEGER_TYPE(result)
                                        x = x[:i+2] + [newtok] + [x[-1]]
                                        raise OutputDirective(Action.IgnoreAndPassThrough)
                                    # Otherwise elide
                                    enable = False
                                elif result:
                                    enable  = True
                                    iftrigger = True
                    else:
                        self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #elif&#34;)
                        
                elif name == &#39;else&#39;:
                    at_front_of_file = False
                    if ifstack:
                        if ifstack[-1].enable:
                            if ifpassthru:
                                enable = True
                                raise OutputDirective(Action.IgnoreAndPassThrough)
                            if enable:
                                enable = False
                            elif not iftrigger:
                                enable = True
                                iftrigger = True
                    else:
                        self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #else&#34;)

                elif name == &#39;endif&#39;:
                    at_front_of_file = False
                    if ifstack:
                        oldifstackentry = ifstack.pop()
                        enable = oldifstackentry.enable
                        iftrigger = oldifstackentry.iftrigger
                        ifpassthru = oldifstackentry.ifpassthru
                        if self.debugout is not None:
                            print(&#34;%d:%d:%d %s:%d      (%s:%d %s)&#34; % (enable, iftrigger, ifpassthru, dirtokens[0].source, dirtokens[0].lineno,
                                oldifstackentry.startlinetoks[0].source, oldifstackentry.startlinetoks[0].lineno, &#34;&#34;.join([n.value for n in oldifstackentry.startlinetoks])), file = self.debugout)
                        skip_auto_pragma_once_possible_check = True
                        if oldifstackentry.rewritten:
                            raise OutputDirective(Action.IgnoreAndPassThrough)
                    else:
                        self.on_error(dirtokens[0].source,dirtokens[0].lineno,&#34;Misplaced #endif&#34;)
                elif name == &#39;pragma&#39; and args[0].value == &#39;once&#39;:
                    if enable:
                        self.include_once[self.source] = None
                elif enable:
                    # Unknown preprocessor directive
                    output_unexpanded_line = (self.on_directive_unknown(dirtokens[0], args, ifpassthru, precedingtoks) is None)

            except OutputDirective as e:
                if e.action == Action.IgnoreAndPassThrough:
                    output_unexpanded_line = True
                elif e.action == Action.IgnoreAndRemove:
                    pass
                else:
                    assert False

        # If there is ever any non-whitespace output outside an include guard, auto pragma once is not possible
        if not skip_auto_pragma_once_possible_check and auto_pragma_once_possible and not ifstack and not all_whitespace:
            auto_pragma_once_possible = False
            if self.debugout is not None:
                print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is not entirely wrapped in an include guard macro, disabling auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, x[0].source, x[0].lineno, self.source), file = self.debugout)
            
        if output_and_expand_line or output_unexpanded_line:
            if not all_whitespace:
                at_front_of_file = False

            # Normal text
            if enable:
                if output_and_expand_line:
                    chunk.extend(x)
                elif output_unexpanded_line:
                    for tok in self.expand_macros(chunk):
                        yield tok
                    chunk = []
                    for tok in x:
                        yield tok
            else:
                # Need to extend with the same number of blank lines
                i = 0
                while i &lt; len(x):
                    if x[i].type not in self.t_WS:
                        del x[i]
                    else:
                        i += 1
                chunk.extend(x)

    for tok in self.expand_macros(chunk):
        yield tok
    chunk = []
    for i in ifstack:
        self.on_error(i.startlinetoks[0].source, i.startlinetoks[0].lineno, &#34;Unterminated &#34; + &#34;&#34;.join([n.value for n in i.startlinetoks]))
    if auto_pragma_once_possible and include_guard and include_guard[1] == 1:
        if self.debugout is not None:
            print(&#34;%d:%d:%d %s:%d Determined that #include \&#34;%s\&#34; is entirely wrapped in an include guard macro called %s, auto-applying #pragma once&#34; % (enable, iftrigger, ifpassthru, self.source, 0, self.source, include_guard[0]), file = self.debugout)
        self.include_once[self.source] = include_guard[0]
    elif self.auto_pragma_once_enabled and self.source not in self.include_once:
        if self.debugout is not None:
            print(&#34;%d:%d:%d %s:%d Did not auto apply #pragma once to this file due to auto_pragma_once_possible=%d, include_guard=%s&#34; % (enable, iftrigger, ifpassthru, self.source, 0, auto_pragma_once_possible, repr(include_guard)), file = self.debugout)
    my_include_time_end = clock()
    self.include_times[my_include_times_idx].elapsed = my_include_time_end - my_include_time_begin
    self.include_depth -= 1</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.token"><code class="name flex">
<span>def <span class="ident">token</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to return individual tokens</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def token(self):
    &#34;&#34;&#34;Method to return individual tokens&#34;&#34;&#34;
    try:
        while True:
            tok = next(self.parser)
            if tok.type not in self.ignore:
                return tok
    except StopIteration:
        self.parser = None
        return None</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.tokenize"><code class="name flex">
<span>def <span class="ident">tokenize</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<section class="desc"><p>Utility function. Given a string of text, tokenize into a list of tokens</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tokenize(self,text):
    &#34;&#34;&#34;Utility function. Given a string of text, tokenize into a list of tokens&#34;&#34;&#34;
    tokens = []
    self.lexer.input(text)
    while True:
        tok = self.lexer.token()
        if not tok: break
        tok.source = &#39;&#39;
        tokens.append(tok)
    return tokens</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.tokenstrip"><code class="name flex">
<span>def <span class="ident">tokenstrip</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove leading/trailing whitespace tokens from a token list</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def tokenstrip(self,tokens):
    &#34;&#34;&#34;Remove leading/trailing whitespace tokens from a token list&#34;&#34;&#34;
    i = 0
    while i &lt; len(tokens) and tokens[i].type in self.t_WS:
        i += 1
    del tokens[:i]
    i = len(tokens)-1
    while i &gt;= 0 and tokens[i].type in self.t_WS:
        i -= 1
    del tokens[i+1:]
    return tokens</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.undef"><code class="name flex">
<span>def <span class="ident">undef</span></span>(<span>self, tokens)</span>
</code></dt>
<dd>
<section class="desc"><p>Undefine a macro</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def undef(self,tokens):
    &#34;&#34;&#34;Undefine a macro&#34;&#34;&#34;
    if isinstance(tokens,STRING_TYPES):
        tokens = self.tokenize(tokens)
    id = tokens[0].value
    try:
        del self.macros[id]
    except LookupError:
        pass</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.Preprocessor.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, oh=&lt;_io.TextIOWrapper name=&#39;&lt;stdout&gt;&#39; mode=&#39;w&#39; encoding=&#39;utf-8&#39;&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Calls token() repeatedly, expanding tokens to their text and writing to the file like stream oh</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write(self, oh=sys.stdout):
    &#34;&#34;&#34;Calls token() repeatedly, expanding tokens to their text and writing to the file like stream oh&#34;&#34;&#34;
    lastlineno = 0
    lastsource = None
    done = False
    blanklines = 0
    while not done:
        emitlinedirective = False
        toks = []
        all_ws = True
        # Accumulate a line
        while not done:
            tok = self.token()
            if not tok:
                done = True
                break
            toks.append(tok)
            if tok.value and tok.value[0] == &#39;\n&#39;:
                break
            if tok.type not in self.t_WS:
                all_ws = False
        if not toks:
            break
        if all_ws:
            # Remove preceding whitespace so it becomes just a LF
            if len(toks) &gt; 1:
                tok = toks[-1]
                toks = [ tok ]
            blanklines += toks[0].value.count(&#39;\n&#39;)
            continue
        # The line in toks is not all whitespace
        emitlinedirective = (blanklines &gt; 6) and self.line_directive is not None
        if hasattr(toks[0], &#39;source&#39;):
            if lastsource is None:
                if toks[0].source is not None:
                    emitlinedirective = True
                lastsource = toks[0].source
            elif lastsource != toks[0].source:
                emitlinedirective = True
                lastsource = toks[0].source
        # Replace consecutive whitespace in output with a single space except at any indent
        first_ws = None
        for n in xrange(len(toks)-1, -1, -1):
            tok = toks[n]
            if first_ws is None:
                if tok.type in self.t_SPACE or len(tok.value) == 0:
                    first_ws = n
            else:
                if tok.type not in self.t_SPACE and len(tok.value) &gt; 0:
                    m = n + 1
                    while m != first_ws:
                        del toks[m]
                        first_ws -= 1
                    first_ws = None
                    if self.compress &gt; 0:
                        # Collapse a token of many whitespace into single
                        if toks[m].value and toks[m].value[0] == &#39; &#39;:
                            toks[m].value = &#39; &#39;
        if not self.compress &gt; 1 and not emitlinedirective:
            newlinesneeded = toks[0].lineno - lastlineno - 1
            if newlinesneeded &gt; 6 and self.line_directive is not None:
                emitlinedirective = True
            else:
                while newlinesneeded &gt; 0:
                    oh.write(&#39;\n&#39;)
                    newlinesneeded -= 1
        lastlineno = toks[0].lineno
        # Account for those newlines in a multiline comment
        if emitlinedirective and self.line_directive is not None:
            oh.write(self.line_directive + &#39; &#39; + str(lastlineno) + (&#39;&#39; if lastsource is None else (&#39; &#34;&#39; + lastsource + &#39;&#34;&#39; )) + &#39;\n&#39;)
        for tok in toks:
            if tok.type == self.t_COMMENT1:
                lastlineno += tok.value.count(&#39;\n&#39;)
        blanklines = 0
        #print toks[0].lineno, 
        for tok in toks:
            #print tok.value,
            oh.write(tok.value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pcpp.preprocessor.PreprocessorHooks" href="#pcpp.preprocessor.PreprocessorHooks">PreprocessorHooks</a></b></code>:
<ul class="hlist">
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.__init__" href="#pcpp.preprocessor.PreprocessorHooks.__init__">__init__</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_comment" href="#pcpp.preprocessor.PreprocessorHooks.on_comment">on_comment</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_directive_handle" href="#pcpp.preprocessor.PreprocessorHooks.on_directive_handle">on_directive_handle</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_directive_unknown" href="#pcpp.preprocessor.PreprocessorHooks.on_directive_unknown">on_directive_unknown</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_error" href="#pcpp.preprocessor.PreprocessorHooks.on_error">on_error</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_file_open" href="#pcpp.preprocessor.PreprocessorHooks.on_file_open">on_file_open</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_include_not_found" href="#pcpp.preprocessor.PreprocessorHooks.on_include_not_found">on_include_not_found</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_potential_include_guard" href="#pcpp.preprocessor.PreprocessorHooks.on_potential_include_guard">on_potential_include_guard</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_defined_expr" href="#pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_defined_expr">on_unknown_macro_in_defined_expr</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_expr" href="#pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_expr">on_unknown_macro_in_expr</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks"><code class="flex name class">
<span>class <span class="ident">PreprocessorHooks</span></span>
</code></dt>
<dd>
<section class="desc"><p>Override these in your subclass of Preprocessor to customise preprocessing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PreprocessorHooks(object):
    &#34;&#34;&#34;Override these in your subclass of Preprocessor to customise preprocessing&#34;&#34;&#34;
    def __init__(self):
        self.lastdirective = None

    def on_error(self,file,line,msg):
        &#34;&#34;&#34;Called when the preprocessor has encountered an error, e.g. malformed input.
        
        The default simply prints to stderr and increments the return code.
        &#34;&#34;&#34;
        print(&#34;%s:%d error: %s&#34; % (file,line,msg), file = sys.stderr)
        self.return_code += 1
        
    def on_file_open(self,is_system_include,includepath):
        &#34;&#34;&#34;Called to open a file for reading.
        
        This hook provides the ability to use ``chardet``, or any other mechanism,
        to inspect a file for its text encoding, and open it appropriately. Be
        aware that this function is used to probe for possible include file locations,
        so ``includepath`` may not exist. If it does not, raise the appropriate
        ``IOError`` exception.
        
        The default calls ``io.open(includepath, &#39;r&#39;, encoding = self.assume_encoding)``,
        examines if it starts with a BOM (if so, it removes it), and returns the file
        object opened. This raises the appropriate exception if the path was not found.
        &#34;&#34;&#34;
        if sys.version_info.major &lt; 3:
            assert self.assume_encoding is None
            ret = open(includepath, &#39;r&#39;)
        else:
            ret = open(includepath, &#39;r&#39;, encoding = self.assume_encoding)
        bom = ret.read(1)
        #print(repr(bom))
        if bom != &#39;\ufeff&#39;:
            ret.seek(0)
        return ret

    def on_include_not_found(self,is_malformed,is_system_include,curdir,includepath):
        &#34;&#34;&#34;Called when a #include wasn&#39;t found.
        
        Raise OutputDirective to pass through or remove, else return
        a suitable path. Remember that Preprocessor.add_path() lets you add search paths.
        
        The default calls ``self.on_error()`` with a suitable error message about the
        include file not found if ``is_malformed`` is False, else a suitable error
        message about a malformed #include, and in both cases raises OutputDirective
        (pass through).
        &#34;&#34;&#34;
        if is_malformed:
            self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Malformed #include statement: %s&#34; % includepath)
        else:
            self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Include file &#39;%s&#39; not found&#34; % includepath)
        raise OutputDirective(Action.IgnoreAndPassThrough)
        
    def on_unknown_macro_in_defined_expr(self,tok):
        &#34;&#34;&#34;Called when an expression passed to an #if contained a defined operator
        performed on something unknown.
        
        Return True if to treat it as defined, False if to treat it as undefined,
        raise OutputDirective to pass through without execution, or return None to
        pass through the mostly expanded #if expression apart from the unknown defined.
        
        The default returns False, as per the C standard.
        &#34;&#34;&#34;
        return False

    def on_unknown_macro_in_expr(self,tok):
        &#34;&#34;&#34;Called when an expression passed to an #if contained something unknown.
        
        Return what value it should be, raise OutputDirective to pass through
        without execution, or return None to pass through the mostly expanded #if
        expression apart from the unknown item.
        
        The default returns a token for an integer 0L, as per the C standard.
        &#34;&#34;&#34;
        tok.type = self.t_INTEGER
        tok.value = self.t_INTEGER_TYPE(&#34;0L&#34;)
        return tok
    
    def on_directive_handle(self,directive,toks,ifpassthru,precedingtoks):
        &#34;&#34;&#34;Called when there is one of
        
        define, include, undef, ifdef, ifndef, if, elif, else, endif
        
        Return True to execute and remove from the output, raise OutputDirective
        to pass through or remove without execution, or return None to execute
        AND pass through to the output (this only works for #define, #undef).
        
        The default returns True (execute and remove from the output).

        directive is the directive, toks is the tokens after the directive,
        ifpassthru is whether we are in passthru mode, precedingtoks is the
        tokens preceding the directive from the # token until the directive.
        &#34;&#34;&#34;
        self.lastdirective = directive
        return True
        
    def on_directive_unknown(self,directive,toks,ifpassthru,precedingtoks):
        &#34;&#34;&#34;Called when the preprocessor encounters a #directive it doesn&#39;t understand.
        This is actually quite an extensive list as it currently only understands:
        
        define, include, undef, ifdef, ifndef, if, elif, else, endif
        
        Return True to remove from the output, raise OutputDirective
        to pass through or remove, or return None to
        pass through into the output.
        
        The default handles #error and #warning by printing to stderr and returning True
        (remove from output). For everything else it returns None (pass through into output).

        directive is the directive, toks is the tokens after the directive,
        ifpassthru is whether we are in passthru mode, precedingtoks is the
        tokens preceding the directive from the # token until the directive.
        &#34;&#34;&#34;
        if directive.value == &#39;error&#39;:
            print(&#34;%s:%d error: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
            self.return_code += 1
            return True
        elif directive.value == &#39;warning&#39;:
            print(&#34;%s:%d warning: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
            return True
        return None
        
    def on_potential_include_guard(self,macro):
        &#34;&#34;&#34;Called when the preprocessor encounters an #ifndef macro or an #if !defined(macro)
        as the first non-whitespace thing in a file. Unlike the other hooks, macro is a string,
        not a token.
        &#34;&#34;&#34;
        pass
    
    def on_comment(self,tok):
        &#34;&#34;&#34;Called when the preprocessor encounters a comment token. You can modify the token
        in place. You must return True to let the comment pass through, else it will be removed.
        
        Returning False or None modifies the token to become whitespace, becoming a single space
        if the comment is a block comment, else a single new line if the comment is a line comment.
        &#34;&#34;&#34;
        return None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pcpp.preprocessor.Preprocessor" href="#pcpp.preprocessor.Preprocessor">Preprocessor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pcpp.preprocessor.PreprocessorHooks.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize self.
See help(type(self)) for accurate signature.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self):
    self.lastdirective = None</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_comment"><code class="name flex">
<span>def <span class="ident">on_comment</span></span>(<span>self, tok)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when the preprocessor encounters a comment token. You can modify the token
in place. You must return True to let the comment pass through, else it will be removed.</p>
<p>Returning False or None modifies the token to become whitespace, becoming a single space
if the comment is a block comment, else a single new line if the comment is a line comment.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_comment(self,tok):
    &#34;&#34;&#34;Called when the preprocessor encounters a comment token. You can modify the token
    in place. You must return True to let the comment pass through, else it will be removed.
    
    Returning False or None modifies the token to become whitespace, becoming a single space
    if the comment is a block comment, else a single new line if the comment is a line comment.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_directive_handle"><code class="name flex">
<span>def <span class="ident">on_directive_handle</span></span>(<span>self, directive, toks, ifpassthru, precedingtoks)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when there is one of</p>
<p>define, include, undef, ifdef, ifndef, if, elif, else, endif</p>
<p>Return True to execute and remove from the output, raise OutputDirective
to pass through or remove without execution, or return None to execute
AND pass through to the output (this only works for #define, #undef).</p>
<p>The default returns True (execute and remove from the output).</p>
<p>directive is the directive, toks is the tokens after the directive,
ifpassthru is whether we are in passthru mode, precedingtoks is the
tokens preceding the directive from the # token until the directive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_directive_handle(self,directive,toks,ifpassthru,precedingtoks):
    &#34;&#34;&#34;Called when there is one of
    
    define, include, undef, ifdef, ifndef, if, elif, else, endif
    
    Return True to execute and remove from the output, raise OutputDirective
    to pass through or remove without execution, or return None to execute
    AND pass through to the output (this only works for #define, #undef).
    
    The default returns True (execute and remove from the output).

    directive is the directive, toks is the tokens after the directive,
    ifpassthru is whether we are in passthru mode, precedingtoks is the
    tokens preceding the directive from the # token until the directive.
    &#34;&#34;&#34;
    self.lastdirective = directive
    return True</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_directive_unknown"><code class="name flex">
<span>def <span class="ident">on_directive_unknown</span></span>(<span>self, directive, toks, ifpassthru, precedingtoks)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when the preprocessor encounters a #directive it doesn't understand.
This is actually quite an extensive list as it currently only understands:</p>
<p>define, include, undef, ifdef, ifndef, if, elif, else, endif</p>
<p>Return True to remove from the output, raise OutputDirective
to pass through or remove, or return None to
pass through into the output.</p>
<p>The default handles #error and #warning by printing to stderr and returning True
(remove from output). For everything else it returns None (pass through into output).</p>
<p>directive is the directive, toks is the tokens after the directive,
ifpassthru is whether we are in passthru mode, precedingtoks is the
tokens preceding the directive from the # token until the directive.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_directive_unknown(self,directive,toks,ifpassthru,precedingtoks):
    &#34;&#34;&#34;Called when the preprocessor encounters a #directive it doesn&#39;t understand.
    This is actually quite an extensive list as it currently only understands:
    
    define, include, undef, ifdef, ifndef, if, elif, else, endif
    
    Return True to remove from the output, raise OutputDirective
    to pass through or remove, or return None to
    pass through into the output.
    
    The default handles #error and #warning by printing to stderr and returning True
    (remove from output). For everything else it returns None (pass through into output).

    directive is the directive, toks is the tokens after the directive,
    ifpassthru is whether we are in passthru mode, precedingtoks is the
    tokens preceding the directive from the # token until the directive.
    &#34;&#34;&#34;
    if directive.value == &#39;error&#39;:
        print(&#34;%s:%d error: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
        self.return_code += 1
        return True
    elif directive.value == &#39;warning&#39;:
        print(&#34;%s:%d warning: %s&#34; % (directive.source,directive.lineno,&#39;&#39;.join(tok.value for tok in toks)), file = sys.stderr)
        return True
    return None</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_error"><code class="name flex">
<span>def <span class="ident">on_error</span></span>(<span>self, file, line, msg)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when the preprocessor has encountered an error, e.g. malformed input.</p>
<p>The default simply prints to stderr and increments the return code.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_error(self,file,line,msg):
    &#34;&#34;&#34;Called when the preprocessor has encountered an error, e.g. malformed input.
    
    The default simply prints to stderr and increments the return code.
    &#34;&#34;&#34;
    print(&#34;%s:%d error: %s&#34; % (file,line,msg), file = sys.stderr)
    self.return_code += 1</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_file_open"><code class="name flex">
<span>def <span class="ident">on_file_open</span></span>(<span>self, is_system_include, includepath)</span>
</code></dt>
<dd>
<section class="desc"><p>Called to open a file for reading.</p>
<p>This hook provides the ability to use <code>chardet</code>, or any other mechanism,
to inspect a file for its text encoding, and open it appropriately. Be
aware that this function is used to probe for possible include file locations,
so <code>includepath</code> may not exist. If it does not, raise the appropriate
<code>IOError</code> exception.</p>
<p>The default calls <code>io.open(includepath, 'r', encoding = self.assume_encoding)</code>,
examines if it starts with a BOM (if so, it removes it), and returns the file
object opened. This raises the appropriate exception if the path was not found.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_file_open(self,is_system_include,includepath):
    &#34;&#34;&#34;Called to open a file for reading.
    
    This hook provides the ability to use ``chardet``, or any other mechanism,
    to inspect a file for its text encoding, and open it appropriately. Be
    aware that this function is used to probe for possible include file locations,
    so ``includepath`` may not exist. If it does not, raise the appropriate
    ``IOError`` exception.
    
    The default calls ``io.open(includepath, &#39;r&#39;, encoding = self.assume_encoding)``,
    examines if it starts with a BOM (if so, it removes it), and returns the file
    object opened. This raises the appropriate exception if the path was not found.
    &#34;&#34;&#34;
    if sys.version_info.major &lt; 3:
        assert self.assume_encoding is None
        ret = open(includepath, &#39;r&#39;)
    else:
        ret = open(includepath, &#39;r&#39;, encoding = self.assume_encoding)
    bom = ret.read(1)
    #print(repr(bom))
    if bom != &#39;\ufeff&#39;:
        ret.seek(0)
    return ret</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_include_not_found"><code class="name flex">
<span>def <span class="ident">on_include_not_found</span></span>(<span>self, is_malformed, is_system_include, curdir, includepath)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when a #include wasn't found.</p>
<p>Raise OutputDirective to pass through or remove, else return
a suitable path. Remember that Preprocessor.add_path() lets you add search paths.</p>
<p>The default calls <code>self.on_error()</code> with a suitable error message about the
include file not found if <code>is_malformed</code> is False, else a suitable error
message about a malformed #include, and in both cases raises OutputDirective
(pass through).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_include_not_found(self,is_malformed,is_system_include,curdir,includepath):
    &#34;&#34;&#34;Called when a #include wasn&#39;t found.
    
    Raise OutputDirective to pass through or remove, else return
    a suitable path. Remember that Preprocessor.add_path() lets you add search paths.
    
    The default calls ``self.on_error()`` with a suitable error message about the
    include file not found if ``is_malformed`` is False, else a suitable error
    message about a malformed #include, and in both cases raises OutputDirective
    (pass through).
    &#34;&#34;&#34;
    if is_malformed:
        self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Malformed #include statement: %s&#34; % includepath)
    else:
        self.on_error(self.lastdirective.source,self.lastdirective.lineno, &#34;Include file &#39;%s&#39; not found&#34; % includepath)
    raise OutputDirective(Action.IgnoreAndPassThrough)</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_potential_include_guard"><code class="name flex">
<span>def <span class="ident">on_potential_include_guard</span></span>(<span>self, macro)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when the preprocessor encounters an #ifndef macro or an #if !defined(macro)
as the first non-whitespace thing in a file. Unlike the other hooks, macro is a string,
not a token.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_potential_include_guard(self,macro):
    &#34;&#34;&#34;Called when the preprocessor encounters an #ifndef macro or an #if !defined(macro)
    as the first non-whitespace thing in a file. Unlike the other hooks, macro is a string,
    not a token.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_defined_expr"><code class="name flex">
<span>def <span class="ident">on_unknown_macro_in_defined_expr</span></span>(<span>self, tok)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when an expression passed to an #if contained a defined operator
performed on something unknown.</p>
<p>Return True if to treat it as defined, False if to treat it as undefined,
raise OutputDirective to pass through without execution, or return None to
pass through the mostly expanded #if expression apart from the unknown defined.</p>
<p>The default returns False, as per the C standard.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_unknown_macro_in_defined_expr(self,tok):
    &#34;&#34;&#34;Called when an expression passed to an #if contained a defined operator
    performed on something unknown.
    
    Return True if to treat it as defined, False if to treat it as undefined,
    raise OutputDirective to pass through without execution, or return None to
    pass through the mostly expanded #if expression apart from the unknown defined.
    
    The default returns False, as per the C standard.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_expr"><code class="name flex">
<span>def <span class="ident">on_unknown_macro_in_expr</span></span>(<span>self, tok)</span>
</code></dt>
<dd>
<section class="desc"><p>Called when an expression passed to an #if contained something unknown.</p>
<p>Return what value it should be, raise OutputDirective to pass through
without execution, or return None to pass through the mostly expanded #if
expression apart from the unknown item.</p>
<p>The default returns a token for an integer 0L, as per the C standard.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def on_unknown_macro_in_expr(self,tok):
    &#34;&#34;&#34;Called when an expression passed to an #if contained something unknown.
    
    Return what value it should be, raise OutputDirective to pass through
    without execution, or return None to pass through the mostly expanded #if
    expression apart from the unknown item.
    
    The default returns a token for an integer 0L, as per the C standard.
    &#34;&#34;&#34;
    tok.type = self.t_INTEGER
    tok.value = self.t_INTEGER_TYPE(&#34;0L&#34;)
    return tok</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pcpp.preprocessor.Action" href="#pcpp.preprocessor.Action">Action</a></code></h4>
<ul class="">
<li><code><a title="pcpp.preprocessor.Action.IgnoreAndPassThrough" href="#pcpp.preprocessor.Action.IgnoreAndPassThrough">IgnoreAndPassThrough</a></code></li>
<li><code><a title="pcpp.preprocessor.Action.IgnoreAndRemove" href="#pcpp.preprocessor.Action.IgnoreAndRemove">IgnoreAndRemove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pcpp.preprocessor.OutputDirective" href="#pcpp.preprocessor.OutputDirective">OutputDirective</a></code></h4>
<ul class="">
<li><code><a title="pcpp.preprocessor.OutputDirective.__init__" href="#pcpp.preprocessor.OutputDirective.__init__">__init__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pcpp.preprocessor.Preprocessor" href="#pcpp.preprocessor.Preprocessor">Preprocessor</a></code></h4>
<ul class="two-column">
<li><code><a title="pcpp.preprocessor.Preprocessor.add_path" href="#pcpp.preprocessor.Preprocessor.add_path">add_path</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.collect_args" href="#pcpp.preprocessor.Preprocessor.collect_args">collect_args</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.define" href="#pcpp.preprocessor.Preprocessor.define">define</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.evalexpr" href="#pcpp.preprocessor.Preprocessor.evalexpr">evalexpr</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.expand_macros" href="#pcpp.preprocessor.Preprocessor.expand_macros">expand_macros</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.group_lines" href="#pcpp.preprocessor.Preprocessor.group_lines">group_lines</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.include" href="#pcpp.preprocessor.Preprocessor.include">include</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.macro_expand_args" href="#pcpp.preprocessor.Preprocessor.macro_expand_args">macro_expand_args</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.macro_prescan" href="#pcpp.preprocessor.Preprocessor.macro_prescan">macro_prescan</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.parse" href="#pcpp.preprocessor.Preprocessor.parse">parse</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.parsegen" href="#pcpp.preprocessor.Preprocessor.parsegen">parsegen</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.token" href="#pcpp.preprocessor.Preprocessor.token">token</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.tokenize" href="#pcpp.preprocessor.Preprocessor.tokenize">tokenize</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.tokenstrip" href="#pcpp.preprocessor.Preprocessor.tokenstrip">tokenstrip</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.undef" href="#pcpp.preprocessor.Preprocessor.undef">undef</a></code></li>
<li><code><a title="pcpp.preprocessor.Preprocessor.write" href="#pcpp.preprocessor.Preprocessor.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pcpp.preprocessor.PreprocessorHooks" href="#pcpp.preprocessor.PreprocessorHooks">PreprocessorHooks</a></code></h4>
<ul class="">
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.__init__" href="#pcpp.preprocessor.PreprocessorHooks.__init__">__init__</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_comment" href="#pcpp.preprocessor.PreprocessorHooks.on_comment">on_comment</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_directive_handle" href="#pcpp.preprocessor.PreprocessorHooks.on_directive_handle">on_directive_handle</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_directive_unknown" href="#pcpp.preprocessor.PreprocessorHooks.on_directive_unknown">on_directive_unknown</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_error" href="#pcpp.preprocessor.PreprocessorHooks.on_error">on_error</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_file_open" href="#pcpp.preprocessor.PreprocessorHooks.on_file_open">on_file_open</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_include_not_found" href="#pcpp.preprocessor.PreprocessorHooks.on_include_not_found">on_include_not_found</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_potential_include_guard" href="#pcpp.preprocessor.PreprocessorHooks.on_potential_include_guard">on_potential_include_guard</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_defined_expr" href="#pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_defined_expr">on_unknown_macro_in_defined_expr</a></code></li>
<li><code><a title="pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_expr" href="#pcpp.preprocessor.PreprocessorHooks.on_unknown_macro_in_expr">on_unknown_macro_in_expr</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>